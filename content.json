[{"title":"ant-vue表单验证","date":"2021-05-27T09:07:38.000Z","path":"/posts/b1f76288/","text":"Ant+vue 时的表单验证 手机号验证123456789101112131415161718192021222324252627282930313233343536userRules = { // 固定电话 validatorTel: [ { required: true, validator: (rule: any, value: any, callback: any) =&gt; { if (!value) { callback(new Error('请输入固定电话（座机）!')); } else { // 正则判断手机号格式的格式，正则判断失败抛出错误，否则直接callback() if (!/(\\d{4}-)?\\d{6,8}/.test(value)) { console.log(/(\\d{4}-)?\\d{6,8}/.test(value), '我要看正则表达式的值'); callback(new Error('格式不正确!')); } else { callback(); } }, trigger: 'blur', }, { // 手机号码 validatorPhone :(rule: any, value: any, callback: any)=&gt; { if (!value) { callback(new Error('请输入手机号!')); } else { // 正则判断手机号格式的格式，正则判断失败抛出错误，否则直接callback() if (!/^1[2-9]\\d{9}$/.test(value)) { callback(new Error('手机号格式不正确!')); } else { callback(); } } } } ] } 只允许输入字母和数字123456789101112131415161718userRules= { { required: true, validator: (rule: any, value: any, callback: any) =&gt; { if (!value) { callback(new Error('请输入用户名!')); } else { // 正则判断手机号格式的格式，正则判断失败抛出错误，否则直接callback() if (/[^A-Za-z0-9]/g.test(value)) { callback(new Error('只能输入字母和数字!')); } else { callback(); } } }, trigger: 'blur', },} 重复确认密码123456789101112131415161718192021userRules= { password: [{ required: true, message: '请输入密码', trigger: 'blur' }], confirmPassword: [ { required: true, validator: (rule, value, callback) =&gt; { if (!value) { callback(new Error('请输入密码')); } else if (value === '') { callback(new Error('请再次输入密码')); } else if (value !== this.schoolForms.password) { callback(new Error('两次输入密码不一致')); } else { callback(); } }, trigger: 'blur', }, ],} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Ant框架","slug":"Ant框架","permalink":"https://cokesprit.gitee.io/tags/Ant%E6%A1%86%E6%9E%B6/"}]},{"title":"jjs修改对象数组里的对象属性名","date":"2021-05-03T03:29:49.000Z","path":"/posts/c9ababfa/","text":"有些时候，后端返回来的 JSON 数据对象，某些字段并不是我们前端想要的，需要对字段进行重命名处理。一般修改对象数组的对象属性名, 常用的方法就是遍历修改，但是这样的处理当数据量很大的时候效率非常低。下面介绍一个更高校的方法，通过正则的方法进行过滤修改。 1234567891011JSON.parse(JSON.stringify(data).replace(/name/g, 'new_name')) //data为数组，name为修改前，new_name为修改后// 解释：(1) JSON.stringify()把json对象转成json字符串；// (2) 使用正则的replace()方法替换属性名；// (3) JSON.parse()把json字符串又转成json对象。// 修改多个属性：当要修改多个属性名时，多次调用replace方法，可以链式调用。如下面说明JSON.parse(JSON.stringify(data).replace(/name1/g, 'new_name1').replace(/name2/g, 'new_name2').replace(/name3/g, 'new_name3')...) 注意：如果对象出现和属性名相同的值，这种方法就没用了； 最好还是通过拷贝出来一个新对象，这样还能避免很多问题的发生： data.map(v=&gt;{return {name: v.title}}) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"天干地支","date":"2021-05-02T09:56:34.000Z","path":"/posts/de5e28/","text":"给年月求天干地支 12345678910111213141516171819202122232425262728293031323334/** * 天干---&gt; 年数减3， 除以10所得余数； * 地支---&gt; 年数减3，除以12所得余数； * * * * **/ console.log(\"天干：\"+(1999-3)%10,\"地支：\"+(1999-3)%12) function calcilate(year) { const sky = [ \"甲\", \"乙\", \"丙\", \"丁\", \"戊\", \"己\", \"庚\", \"辛\", \"壬\", \"癸\"]; const land = [ '子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']; let d = (year-3)%10; // 天干 let l = (year-3)%12; // 地支 return { sky: sky[d-1], land: land[l-1] } } let obj = calcilate(1996); console.log('天干地支：'+ obj.sky + '' + obj.land); /** * 1999 --&gt; 己卯 * 1999 --&gt; 丙子 * * */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"玄学","slug":"玄学","permalink":"https://cokesprit.gitee.io/tags/%E7%8E%84%E5%AD%A6/"}]},{"title":"Vue中created和mmounted","date":"2021-04-07T08:39:40.000Z","path":"/posts/74e93217/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"ant框架Upload组件限定上传文件格式","date":"2021-03-31T08:20:05.000Z","path":"/posts/494a661/","text":"设置上传文件类型为excel 123456789101112&lt;template&gt; &lt;a-upload name=\"file\" :multiple=\"true\" action=\"https://www.mocky.io/v2/5cc8019d300000980a055e76\" :headers=\"headers\" @change=\"handleChange\" accept=\"application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" &gt; &lt;a-button&gt; &lt;a-icon type=\"upload\" /&gt; Upload &lt;/a-button&gt; &lt;/a-upload&gt;&lt;/template&gt; 注意：For Excel Files 2003-2007 (.xls), use: application/vnd.ms-excel For Excel Files 2010 (.xlsx), use:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet 设置上传文件类型为zip 1234567891011&lt;template&gt; &lt;a-upload name=\"file\" :multiple=\"true\" action=\"https://www.mocky.io/v2/5cc8019d300000980a055e76\" :headers=\"headers\" @change=\"handleChange\" accept=\"application/zip\"&gt; &lt;a-button&gt; &lt;a-icon type=\"upload\" /&gt; Upload &lt;/a-button&gt; &lt;/a-upload&gt;&lt;/template&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Ant框架","slug":"Ant框架","permalink":"https://cokesprit.gitee.io/tags/Ant%E6%A1%86%E6%9E%B6/"}]},{"title":"ES6中的Set","date":"2021-03-28T12:39:46.000Z","path":"/posts/c0c56f47/","text":"Set是 ES6 中引入的新的数据类型，Set只允许存储不重复的值，当你放入一个数组的时候它会自动去掉重复值。返回的是一个对象。 12345678const arrSave = [1, 2, 3, 4, 3, 2];const uniqueSet = new Set(arrSave); // 返回的是一个对象// 转回数组const backToArray = [...uniqueSet]; // 展开// 或者let arrfrom = Array.from(new Set(arrSave)); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"Promise","date":"2021-03-24T03:57:27.000Z","path":"/posts/54b11a0c/","text":"什么是Promise呢？Promise 到底是做什么的呢？Promise是异步编程的一种解决方案。 那什么时候我们会处理异步事件呢? 一种很常见的场景应该就是网络请求了。 我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像简单的3+4=7一样将结果返回. 所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去。 如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦。 回调地狱 当网络请求非常复杂时，就会出现回调地狱. 什么情况用到Promise?一般情况下是有异步操作时，使用Promise对即将进行的异步操作进行封装 Promise的基本上使用在执行传入的回调函数是，会传入两个参数， resolve, reject.本身又是函数 12345678910111213141516171819202122new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // 使用setTimeout模拟异步操作 // 成功的时候调用resolve resolve('Hello Word'); // 失败的时候调用reject // reject('error message') }, 1000);}).then((data) =&gt; {// 成功的时候来到这里面 console.log(data); console.log(data); console.log(data); console.log(data); console.log(data);}).catch((err) =&gt; { // 失败的时候来到catch里面 console.log(err);}); Promise的三种状态12345678910111213/**** * 首先，当我们开发中有异步操作时，就可以给异步操作包装一个 * Promise * * 异步操作之后会有三种状态: * pending: 等待状态，比如正在进行网络请求，或者定时器没有到事件。 * * fulfill：瞒住状态，当我们主动回调了resolve时，就处于该状态，并且回调.then() * * reject： 拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch() * * **/ Promise的链式调用链式调用简写需求 网络请求： aaa -&gt; 自己处理(10行) 处理：aaa111 -&gt; 自己处理(10行) 处理：aaa111222 -&gt; 自己处理 12345678910111213141516171819202122232425262728293031323334353637383940// 简写一 -&gt; new Promise(resolve =&gt; resolve(结果))简写 // new Promise((resolve, reject) =&gt; { // setTimeout(() =&gt; { // resolve('aaa'); // }, 1000); // }).then(res =&gt; { // console.log('自己处理(10行)'); // return Promise.resolve(res + '111'); // }).then(res =&gt; { // console.log(res, '第二层的10行处理代码'); // return Promise.resolve(res + '222'); // }).then(res =&gt; { // console.log(res, '第三层的10行处理代码'); // }) // 简写二 new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('aaa'); }, 1000); }).then(res =&gt; { console.log('自己处理(10行)'); return (res + '111'); }).then(res =&gt; { console.log(res, '第二层的10行处理代码'); return (res + '222'); }).then(res =&gt; { console.log(res, '第三层的10行处理代码'); }) 错误处理并不是每一次都是成功的，当某一层报错的时候可以使用Promise.reject 或者 throw； 1234567891011121314151617181920212223new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('aaa'); }, 1000); }).then(res =&gt; { console.log('自己处理(10行)'); // 使用 throw 或者 Promise.reject throw '抛出一个异常'; // return Promise.reject('error message'); }).then(res =&gt; { console.log(res, '第二层的10行处理代码'); return Promise.resolve(res + '222'); }).then(res =&gt; { console.log(res, '第三层的10行处理代码'); }).catch(err =&gt; { console.log(err); }); Promise的all方法当有需求需要发送多个请求，需要多个结果的时候就可以使用Promise的all方法 ，在说Promise的all方法之前，先了解我们没有Promise前的处理方法： 没有Promise之前的处理方法123456789101112131415161718192021222324252627let isResult1 = false; let isResult2 = false; // 请求一 $ajax({ url: '', success: function () { console.log('结果1'); isResult1 = true; handleResult(); } }); // 请求二 $ajax({ url: '', success: function () { console.log('结果2'); isResult2 = true; handleResult(); } }) function handleResult(){ if(isResult1 &amp;&amp; isResult2) { } } Promise.all1234567891011121314151617Promise.all({ // 使用setTimeout模拟 ajax new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve({name: 'cokeSprit', age: 18}) }, 1000) }), new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve({name: 'mi', age: '11'}) }, 1500) })}).then(results =&gt; { console.log(resuelt);}) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"ES6 Symbol","date":"2021-03-23T03:50:17.000Z","path":"/posts/67f282b/","text":"ES6引入了一种新的原始数据类型Symbol,表示独一无二的值，最大的用法是用来定义对象的谓语属性名。 基本用法Symbol函数栈不能用new命令，因为Symbol是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的Symbol提供描述，用来显示控制台或者未做字符串的使用，便于区分。 123456789// Symbollet sy = Symbol(\"kk\");console.log(sy); // Symbol(kk)// typeof(sy)console.log(typeof(sy)); // symbol// 相同的参数 Symbol() 返回的值不相等let sy1 = Symbol(\"kk\");console.log(sy === sy1); // false 使用场景 1. 作为属性名 由于每个Symbol的值都是不相等的，所以Symbol作为对象的属性名，可以保证属性不重名。 123456789101112131415161718192021222324252627let sytwo = Symbol(\"key1\");// 写法1 let syObject = {name: \"晓明\", age: 18, sex: \"男\"};syObject[sytwo] = \"kk\";console.log(syObject);// {name: \"晓明\", age: 18, sex: \"男\", Symbol(key1): \"kk\"}}// 写法二let syObjectwo = { [sytwo]: \"kk\"};console.log(syObjectwo);// {Symbol(key): \"kk\"}/*** * Symbol 作为对象属性名时不能用‘.’运算符，要用方括号。 * 因为‘.'运算符后面是字符串'，所以渠道的是字符串sy_属性 * 而不是Symbol值sy_属性 * */ let sy_ = Symbol(\"key1\"); let syObjectThree = {}; syObjectThree[sy_] = \"kk\"; console.log(syObjectThree[sy_],syObjectThree.sy_); // kk undefined 2. 定义常量 在ES5中使用字符串表示常量。例如 123const COLOR_RED = \"red\";const COLOR_YELLOW = \"yellow\";const COLOR_BLUE = \"blue\"; 但是用字符串不能保证常量是独特的，使用 Symbol 定义常量，这样就可以保证这一组常量的值都不相等。例如： 1234567891011121314151617181920212223242526272829const COLOR_RED = Symbol(\"red\"); const COLOR_YELLOW = Symbol(\"yellow\"); const COLOR_BLUE = Symbol(\"blue\"); function ColorException(message) { this.message = message; this.name = \"ColorException\" } function getConstantName(color) { switch (color) { case COLOR_RED: return \"COLOR_RED\"; case COLOR_BLUE: return \"COLOR_BLUE\"; case COLOR_YELLOW: return \"COLOR_YELLOW\" default: throw new ColorException(\"Can't find this color\"); } } try { var color = \"green\"; // green 引发异常 var colorName = getConstantName(color); } catch (e) { var colorName = \"unknown\"; console.log(e.message, e.name); // 传递异常对象到错误处理 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"Object.assgin()方法","date":"2021-03-23T03:23:25.000Z","path":"/posts/aefdbfd2/","text":"Object.assign()方法，用于将所有可枚举属性的值，从一个或多个源对象分配到目标对象。分配完成返回目标对象 语法：Object.assgin(target, ...sources); 参数：target 目标对象， sources 源对象 返回值：目标对象 描述：如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。Object.assgin方法只会拷贝源对象自身的并且可以枚举的属性到目标对象。 123456789101112131415161718192021222324// 复制一个对象const obj = {a: 1}const copy = Object.assgin({}, obj);copy.name = \"小米\"; // 源对象并不会受到影响console.log(copy, obj); //{a: 1, name: \"小米\"} {a: 1}// 和并对象const o1 = {a: 1};const o2 = {b: 3};const o3 = {c: 6};const objtwo = Object.assign(o1, o2, o3);console.log(objtwo);// {a: 1, b: 3, c: 6} console.log(o1); // {a: 1, b: 2, c: 3}, 注意目标对象自身也会改变// 合并具有相同属性的对象const ob1 = {a: 1, b: 1, c: 1};const ob2 = {b: 2, c: 2};const ob3 = {c: 3};const objthree = Object.assgin({}, ob1, ob2, ob3);console.log(objthree); // {a: 1, b: 2, c: 3};// 属性被后续参数中具有相同属性的其他对象覆盖。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JavaScript标准内置对象","slug":"JavaScript标准内置对象","permalink":"https://cokesprit.gitee.io/tags/JavaScript%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"}]},{"title":"Vue+ant上传文件","date":"2021-03-23T01:42:54.000Z","path":"/posts/a3b41ae0/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"vue + ant desigin 之table操作按钮获取当期行的数据","date":"2021-03-18T02:37:31.000Z","path":"/posts/bfbb9d3e/","text":"通过单击获取到table当前行的数据html 12345678910111213&lt;a-table :columns=\"notificationkColumns\" :data-source=\"notificationData\" :pagination=\"{pageSize: 3}\" :bordered=\"true\" style=\"min-width: 800px\"&gt; &lt;!-- 通过设置 slot-scope 把当前 record 传过去 --&gt; &lt;div slot=\"action\" slot-scope=\"text, record\"&gt; &lt;a slot-scope=\"\" href=\"javascript:;\" @click=\"showModal\"&gt;编辑&lt;/a&gt;&amp;nbsp; &lt;a slot-scope=\"\" href=\"javascript:;\" @click=\"getNowRowKey(record)\"&gt;删除&lt;/a&gt; &lt;/div&gt;&lt;/a-table&gt; js 123getNowRowKey(record){ console.log(record.key); // 拿到当前的key} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Ant框架","slug":"Ant框架","permalink":"https://cokesprit.gitee.io/tags/Ant%E6%A1%86%E6%9E%B6/"}]},{"title":"Vue中的计算器属性和侦听属性","date":"2021-02-25T01:33:38.000Z","path":"/posts/2e0050e8/","text":"计算属性对于任何任何复杂的逻辑，都应该当使用计算属性。 计算属性的基本使用实现变量message的翻转字符串 12345678&lt;div id=\"app\"&gt; &lt;p&gt; Original message :\"{{message}}\" &lt;/p&gt; &lt;p&gt; Computed reveersed message :\"{{reversedMessage}}\" &lt;/p&gt;&lt;/div&gt; 123456789101112var vm = new Vue({ el: \"app\", data: { message: \"Hello\" }, computed: { reversedMessage: function() { return this.message.split('').reverse().join(''); } } }) 计算属性缓存VS方法123&lt;p&gt; Reversed message: \"{{reversedMessage()}}\"&lt;/p&gt; 12345methods: { reversedMessage(){ retrun this.message.split('').reverse().join(); }} 两种方式的最终结果是完全相同的。然而，不同的是计算属性是基于他们的响应式迎来进行缓存的。只在相关依赖发生改变时它们才会重新求值。意味着只要message还没发生改变，多次访问reversedMessage计算属性会立即返回之前的计算结果，而不必再次执行函数。 相比执行，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性vs监听属性Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：监听属性 123&lt;div id=\"demo\"&gt; {{fullName}}&lt;/div&gt; 12345678910111213141516var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { fistName:function (val){ this.fullName = val + ' '+this.lastName; }, lastName: function (val){ this.fullName = this.firstName + ' '+val; } }}) 上面的代码是命令式且重复。将它与计算属性的版本进行比较 123456789101112var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { funllName: function(){ return this.lastName + ' ' + this.lastName; } } }) 是不是好很多 计算属性的setter计算属性默认只有getter,不过在需要时也可以提供一个setter: 12345678910111213141516// ...computed: { fullName: { //getter get: function() { return this.fistName + ' ' + this.lastName; }, // setter set: function(newValue) { var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length - 1] } }} 现在再次运行 vm.fullName = “John Doe” 时，setter会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 侦听器虽然计算属性在大多数情况下更合适，但有也需要一个自定义的侦听器。这就是为什么Vue通过watch选项提供了一个通过的方法，来相应数据的变化。当需要在数据变化时只需异步或开销较大的操作时，这个方式最有用的。 列如: 1234567891011121314&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input type=\"text\" v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt; {{answer}} &lt;/p&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() } }, created: function () { // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)' return } this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } } }) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue","slug":"Vue","permalink":"https://cokesprit.gitee.io/tags/Vue/"}]},{"title":"TypeScript数据类型","date":"2021-01-28T11:35:57.000Z","path":"/posts/fce3f7c8/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"TypeScript的安装","date":"2021-01-28T11:34:41.000Z","path":"/posts/40ee0c06/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"表单、表单标签属性、标签总结","date":"2020-10-23T02:06:17.000Z","path":"/posts/dbb51634/","text":"form 标签 123456block element配合input 和 提交按钮method: get | postaction: 提交数据的后端地址，不写就是本页面 input 标签 1234567891011121314151617181920inline block elementname：为了提交数据设置名称type： text -&gt; 文本框 password -&gt; 密码框 submit -&gt; 提交按钮： 提交数据的两大要素： 名称 和 值 名称是 input 的name属性的值；一定要写！！！ radio -&gt; 单选按钮 checkbox -&gt; 多选课maxlength: 最大可输入的字符readyonly: 只读属性；不可输入，表单提交时会是会提交数据。disabled: 禁用；表单提交时不提交数据readonly 和 disabled 区别： 前者表单提交数据时会提交数据，后者不提交数据。placeholder：默认内容onfocus：聚焦的方法onblur：失去焦点的方法 lable 1234567inline elementfor属性lable的最大价值： lable 的 for 属性与某个input的属性的值相同时， 点击lable可以自动聚焦 select 下拉框 1234567子项：option&lt;select name=\"lang\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option &gt;JavaScript&lt;/option&gt; &lt;option &gt;JAVA&lt;/option&gt;&lt;/select&gt; textarea 多行文本框 1234567891011cols: 可见宽度 宽度计算(大概)：8px * cols +17px(滚动条); 8个像素是指英文字符,而且是在浏览器默认字体(16px)大小的情况下。rows：可见行数placeholder：默认内容补充：为什么在多行文本里面会出现空格的现象？ 因为 textarea 它的文本是在这两个双标签之间， 换行和空格相当占用了它的字符显示。 fieldset 控件组 1234567891011121314151617block elementlegend -&gt; block element&lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; &lt;p&gt; &lt;label for=\"username\"&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"\" id=\"username\" placeholder=\"用户名\"/&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"\" id=\"password\" placeholder=\"密码\"/&gt; &lt;/p&gt;&lt;/fieldset&gt;fieldset控件组可以自定义样式！！！ 效果： 前端验证 123456前端验证：长度验证、字符验证 md5加密：“消息摘要的算法”或者“不可逆加密算法” 1.不可逆加密算法 2.只要加密了就不可以解密 3.这种加密方式是不需要提供额外秘钥的 总结：常用标签内联元素：span / strong / em / lable / del(删除线) / ins(下划线) / a / sup(上标) / sub(下标) 块级元素：div / h1-6 / p / address / ul / ol / li / dl / dt / dd / table / form / fieldset / legend 内联块元素：input / img / select / textarea / iframe(内联框架) HTML4.0 有89个标签(十分之3常用)，HTML5标签新增30个标签，二分之一是有用的，其他要不然是兼容性不行或者是功能性太强。不到一定web发展阶段是很难有出路的。 题外话HTML5 和 HTML5技术 HTML是 HTML的新标准 更新：简化编码的声明的方式 删除：center font big small framest frame s u 等等 新增：增加了音视频标签video、audio；header nav footer，canvas画布等等。 增加 JavaScript API: 地理位置、离线缓存、canvas 应用缓存 CSS3：过渡、转换、动画 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"基础标签、列表、框架","date":"2020-10-23T00:02:55.000Z","path":"/posts/5e8fe3d2/","text":"sub &amp; sup 标签1234567sub：下标标签 -&gt; subscriptedsup：上标标签 -&gt; superscripted两个都是inline element前端&lt;sup&gt;&lt;a href=\"\" target=\"_blank\"&gt;1&lt;/a&gt;&lt;sup/&gt; &lt;br/&gt;H&lt;sub&gt;2&lt;/sub&gt;SO&lt;sub&gt;4&lt;/sub&gt; 效果： span 标签1234没有任何的样式为什么要用span标签？ 在一个文本内为了区分其他文本的样式差别； 为了获取文章中某些字； ol 有序列表12345678910111213全称：order listtyoe：可取1、A、a、I、istart：只能写数字 从第几位开始reversed: 倒序&lt;ol type=\"1\" start=\"5\" reversed&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;PHP&lt;/li&gt; &lt;li&gt;Pythone&lt;/li&gt; &lt;li&gt;JAVA&lt;/li&gt;&lt;/ol&gt; ul 无序列表1234567全称：unorder list 无序列表type：disk -&gt; 默认 square -&gt; 黑色方框 circle -&gt; 圆最大的用处写Tab组件/轮播图，平分区域或者是横排列的块级布局，横排列表/竖排列表。 效果： dl 定义列表1234567891011全称：definition listdt：项 -&gt; definiton termdd：描述 -&gt; definition description&lt;dl&gt; &lt;dt&gt;我的梦想&lt;/dt&gt; &lt;dd&gt;我要成为WEB开发工程师&lt;/dd&gt; &lt;dt&gt;我的梦想&lt;/dt&gt; &lt;dd&gt;我要成后端工程师&lt;/dd&gt; &lt;dt&gt;我的梦想&lt;/dt&gt; &lt;/dl&gt; frameset 页面框架123可以快速的把页面框架加起来；使用这个框架不能有body!!!现在已经不使用了 table 表格12345678910111213141516171819caption -&gt; 表格的标题标签tr -&gt; table row 表格的行标签th -&gt; table header call 表头标签td -&gt; table data cell 单元格标签border -&gt; 表格边框； border = 1 ; 不能有单位cellpadding -&gt; 单元内格边距 不能有单位cellspacing -&gt; 单元格间距 不能有但我colspan -&gt; 列和并，表格的数加起来要等于列数rowspan -&gt; 行合并align: left | center | rightthead -&gt; 表格也页眉标签 table headtfoot -&gt; 表格尾页标签 table foottbody -&gt; 表格的主体标签 table body 这三个标签必须同时出现！！！ 如果不加这三个标签表格要等所有的内容加载完毕了之后， 才会渲染出来；加了这三个标签页眉和页尾先加载出来然后 再加载主体部分，所以这个三个标签的出现循序是： thead -&gt; tfood -&gt; tbody 例子 12345678910111213141516171819202122232425262728293031323334&lt;table border=\"1\" cellpadding=\"10\" cellspacing=\"5\"&gt; &lt;caption&gt; 学生管理系统 &lt;/caption&gt; &lt;thead&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;181203010934&lt;/td&gt; &lt;td&gt;黄一蓝&lt;/td&gt; &lt;td rowspan=\"2\"&gt;1812030109&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;181203010934&lt;/td&gt; &lt;td&gt;陶一蓝&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;181203010933&lt;/td&gt; &lt;td&gt;张晓蓝&lt;/td&gt; &lt;td colspan=\"2\"&gt;1812030109 、女&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"4\" align=\"right\"&gt;学生都可以顺利毕业&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 运行结果： iframe 内联框架123456789101112131415161718192021222324iframe 是重frameset衍生出来的；页面占用少，而且有body；inline-block elementframboder：添加像素scrolling：禁用/许可 滚动条；取值：yes | no | auto优点： 不需要去加载整个页面，只加载ifname的页面； 变相的减少了Http请求; 像功能性导航用ifname来做挺好的；缺点：最恶心的缺点是对搜索引擎不友好； 滚动条的题型混乱，各个浏览器的都是不太一样； 之间的数据传递非常困难； &lt;p&gt; &lt;a href=\"http://wwww.taobao.com\" target=\"mainFrame\"&gt;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt; &lt;a href=\"http://wwww.baidu.com\" target=\"mainFrame\"&gt;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt; &lt;a href=\"http://wwww.taobao.com\" target=\"mainFrame\"&gt;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;iframe src=\"https://baidu.com\" width=\"600px\" height=\"200px\" name=\"mainFrame\" frameborder=\"0\" &gt;&lt;/iframe&gt; 效果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"HTML基础、编码、基础标签","date":"2020-10-22T09:37:28.000Z","path":"/posts/95ef9666/","text":"前端开发：结构布局、样式呈现、页面动态交互(js脚本，数据交互处理、数据格式渲染) 对应：HTML CSS JavaScript 为什么出现htm? win98 及之前的系统基本上都只认后缀名3位，不认三位以上的 HTML全称： 超文本标记语言 &lt;!DOCTYPE html&gt;这个并不是标签；作用告诉浏览器HTML用哪个版本来编写，&lt;!DOCTYPE html&gt; HTML5的声明方式。 CSS1Compat：是W3C的标准兼容性模式 BackCompat：是浏览器的怪异兼容性模式，会用一些样式或者兼容的问题 要使用&lt;!DOCTYPE html&gt;变回标准模式。 标签：双标签单标签 -&gt; 单标签必须闭合 html 根标签：12345&lt;html lang=\"zh-CN\"&gt; zh-CN: 中华人民共和国 - 简体中文 EN: 英文zh-Hans: 纯简体中文 -&gt; 部分地域zh-CHS: 纯简体中文 -&gt; 部分地域 head标签head标签向浏览器网页的基本信息和配置1234567891011121314151617三大件： title: &lt;title&gt;30-40个字&lt;/title&gt; 主页：网站 + 主要关键字/关键字的描述 详情页：详情名称 + 网站名称 + 简介 列表页：分类名称 + 关键字 + 网站名称 文章页：标题 + 分类 + 网站名称 keywords: &lt;meta name=\"keywords\" content=\"\"&gt; 要求100个字符 网站名称 + 分类信息 + 网站名称 description: &lt;meta name=\"description\" centent=\"\"&gt; 描述信息 80 - 120 汉字 综合title + keywords的简单问题 12345678910111213141516171819/****************************分割*********************/搜索引擎认知的优先级： title &gt; description &gt; keywords搜索引擎： 是有学习能力的，每隔一段时间自动启动蜘蛛爬虫程序，爬别人网页上的内容，会对一定范围之内的网站进行搜索，搜索到了存在到自己的数据库。爬虫程序对语义化标签非常青睐。搜索引擎的优化： 并不是网页技术，它实际到方方面面，比如网页的营销。编码字符集： &lt;meta charset=\"UTF-8\"&gt; GB2312：中国信息处理国家标准码 -&gt; 简体中文编码 GBK：汉字扩展规范 -&gt; 扩大了汉字的收入，增加了繁体中文、藏、蒙、维吾尔等少数民族的文字 UTF-8：万国码 -&gt; 它几乎认识世界所有文字 h1-h6-&gt;标签12h1-h6：粗体、独占一行其中h1标签的文字大小是2em;补充：浏览器默认的文字大小16px Paragraph 标签：1段落标签，独占一行，p标签设置text-decoration: line-through;有删除线 strong &amp; b123456&lt;strong&gt;我是strong&lt;/strong&gt;b&gt;我是bold&lt;/b&gt; 都是字体加粗； 这两个的区别是，前者是语义化标签； 后者是物理化标签，语义化标签标示加强； 搜索引擎的爬虫程序很青睐它 em &amp; i 标签123设置斜体&lt;em&gt;我是 emphasize 标签&lt;/em&gt; -&gt;语义化标签 &lt;i&gt;现在i标签用在图标上&lt;/i&gt; del 标签12删除线&lt;del&gt;我是delete标签&lt;/del&gt; ins 标签12下划线&lt;ins&gt;我是insert标签&lt;/ins&gt; address 标签12语义表示地址&lt;address&gt;北海市银海区南珠大道9号&lt;/address&gt; division 标签 div标签12345它叫容器，也叫盒子是容器/盒子就一定有宽高，有宽和高的容器它就一定是块。H5的标签一些语义化标签，为什么要代替div? 编辑器：1在编辑器内文本的换行和空额都是文本分隔符 html实体字符：123&amp;nbsp; -&gt; 空格&amp;lt; -&gt; 小于号&amp;gt; -&gt; 大于号 hr &amp; br 标签123&lt;hr/&gt; &lt;br/&gt;下划线和换行符开发项目的时候都不要用它们！！！ img 标签12345678&lt;img src=\"../img/1.png\" alt=\"胡歌\" title=\"胡歌\"/&gt;绝对路径：完整的描述文件位置的路径就是绝对路径。相对路径：这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。跳出文件夹用：../img/1.png 上一级alt：图片加载失败的时候才会起作用，必须要写。title：鼠标放上去会显示图片信息，可选。 anchor 标签 (锚点)12345678910111213&lt;a target=\"_blank\" href=\"https://www.baidu.com\"&gt;最早是锚点标签&lt;a/&gt;href：target：_blank 新开一个页面a标签的作用： 1、超链接标签 2、打电话 &lt;a href=\"tel:17677537662\"&gt;联系商家&lt;/a&gt; 3、发邮件 &lt;a href=\"mailto:2665281140@qq.com\"&gt;发邮件&lt;/a&gt; 4、锚点定位 5、协议限定 &lt;a href=\"JavaScript:;\"&gt;&lt;/a&gt; 元素元素 == 标签 + 元素内容； -&gt; &lt;p&gt;元素&lt;/p&gt; 12345678910111213 内联元素(专业叫法) 也叫行间元素 行内元素 inline element ： inline element 不独占一行，无法定义宽高 strong em del ins块级元素 -&gt; block element : 独占一行、可以定义宽高 p hx div address内联块级元素 -&gt; inline-block element : 不独占一行、可以定义宽高 img &lt;img src=\"img/1.png\" alt=\"\" /&gt;123 提示：块级元素可以嵌套任何元素。p标签不可以嵌套div;a标签不可以嵌套a标签; 语义化标签和物理化标签的区别123456标签存在了语义之后： 1.可读性强 2.可为维护性强 3.搜索引擎对语义化的东西是比较青睐的 HTML的房子方向：就是语义化的发展的方向 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://cokesprit.gitee.io/tags/HTML-CSS/"}]},{"title":"Symbol.iterator 迭代器","date":"2020-10-22T07:58:03.000Z","path":"/posts/ad9de38b/","text":"IteratorIterator是ES6引入的一种新的遍历机制，迭代器有两个核心的概念：1.跌迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个件为Symbol.iterator的方法来实现。 2.迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。 迭代器：是对数据结构读取的一种方式，有序的，连续的，基于拉取的一种消耗的组织方式； 迭代过程通过Symbol.iterator创建一个迭代器，指向当前数据结构的起始位置；随后通过next方法进行向下迭代指向下一个目标位置，next方法会返回当前位置的对象，对包含了value和done两个属性，value是当前属性的值，done用于判断是否遍历结束;当done为ture时则遍历结束。 JavaScript 1234567891011let arr = [1,2,3,4];// 当前数组上面存在一个迭代器的接口let iter = arr[Symbol.iterator](); console.log(iter); //Array Iterator&nbsp;{}console.log(iter.next()); //{value: 1, done: false} console.log(iter.next());//{value: 2, done: false} console.log(iter.next());//{value: 3, done: false} console.log(iter.next());//{value: 4, done: false} console.log(iter.next()); //{value: undefined, done: true} for…of循环for…of 是ES6新引入的循环，用于替代for..in 和 forEach(),并且支持新的迭代协议。它可用于迭代常规的数据类型，如 Array 、 String 、 Map 和 Set 等等。 JavaScript 12345let arr = [1,2,3,4];for(let i of arr){ console.log(i);} 注意：of操作数碧玺是可迭代，这意味着如果是普通对象则无法进行迭代。如果数据结构类似于数据的形式，则可以借助Array.from()方法进行转换迭代。 123456789101112131415const arr = {length: 2, 0: \"zero\", 1: \"one\"}; // 报异常for (let item of arrayLink) { console.log(item);}// 正常运行for(let item of Array.from(arr)){ console.log(item);}// 输出:// zero// one 可迭代的数据Array 、Map、Set、weekMap、weekSet、arguments; nodeListTypeArray 对于这些数据类型给一种统一的迭代方法，这就是迭代器的意义所在。 实现迭代器 -&gt; IteratorJavaScript 123456789101112131415161718192021function makeIterator(array){ var nextIndex = 0; return { next: function(){ return nextIndex &lt; array.length ? { value:array[nextIndex++],done:false }: { value: undefined, done: true } } }}var mIter = makeIterator([1,2,3,4]);console.log(mIter.next());console.log(mIter.next());console.log(mIter.next());console.log(mIter.next());console.log(mIter.next()); 部署Iterator接口JavaScript 123456789101112131415161718192021222324252627282930313233let obj = { start: [1,2,3,4], end: [7,8,9], [Symbol.iterator](){ let index = 0, arr = [...this.start,...this.end], len = arr.length; console.log(arr.length); return { next(){ if(index &lt; len){ return { value: arr[index++], done: false } }else{ return { value: undefined, done: true } } } } }}// 使用for...of循环for(let i of obj){ console.log(i);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"箭头函数的实质&使用场景","date":"2020-10-22T02:19:02.000Z","path":"/posts/38c66610/","text":"箭头函数的实质箭头函数的this指向问题箭头函数的 this 指向是固化的，箭头函数的内部并没有自己的 this ,只能通过父级作用域来获取 this , 这里的this实际是闭包的this。 例子一 12345678910111213141516 function foo(){ return (a) =&gt; { console.log(this.a); } } var obj1 = {a:2};var obj2 = {a:3};// 结果一 var bar = foo.call(obj1); bar.call(obj2); //2// 结果二 var bars = foo(); bars.call(obj2); //undefined 并没有打印出a 的值 例子二 123456789101112const person = { // 对象里面的function冒号可以简写 eat(){ console.l0g(this); // person }, drind: () =&gt; { console.log(this); // window }}person.eat(); //谁调用指向谁person.drind(); 箭头函数不能作为构造函数来使用箭头函数没有this ，不能作为构造函数来使用。 没有 arguments 对象箭头函数没有arguments对象,用 rest(扩展运算符)替代 1234567891011121314// 报错 var test = () =&gt;{ console.log(arguments); } test(); // 报错// 不报错 function foo(){ setTimeout(()=&gt;{ console.log(arguments); // 这里打印的是foo的arguments },1000); } foo(); yeid命令不能生效yied 命令不能生效，在generator 函数中 练习把下面这个函数缓存箭头函数的写法 12345678910111213function insert(value){ return { into: function(array){ return { after: function(afterValue){ array.splice(array.indexOf(afterValue)+ 1, 0, value); } } } }}// 插入 console.log(insert(5).into([1,2,3,4,6,7]).after(4)); 箭头函数写法 12345678910// 改成这样 但是还是不建议这么写 因为语义化不是很好 let insert = (value) =&gt; ({ into:(array) =&gt; ({ after:(afterValue) =&gt; { array.splice(array.indexOf(afterValue)+1, 0,value); return array; } }) }); 箭头函数使用场景总结1、简单的函数表达式，得出唯一的return 的计算，函数内部没有this引用，没有递归、事件绑定、解绑定、用重构箭头函数的方式。 2、内层函数的函数的表达式需要的是调用this 1&lt;button id=\"button\"&gt;button&lt;/button&gt; JavaScript 123456789101112131415161718192021222324252627(function(){ function Button(){ this.button = document.getElementById('button'); } Button.prototype = { init(){ this.bindEvent(); }, bindEvent(){ console.log(this); // 传统方式 // 改变this指向 让它指向window // this.button.addEventListener('click',this.clickBtn.bind(this),false); // 箭头函数的方式 -&gt; 箭头函数的使用场景 通过父级作用域获取到this this.button.addEventListener('click',(e) =&gt; this.clickBtn(e),false) }, clickBtn(e){ console.log(e); console.log(this); } } new Button().init();})(); 3、当你考虑用到arguments/sort把类数组转化成数组时 1234567891011// 传统方式function sortNumber(){ var args = Array.prototype.slice.call(arguments); return args.sort(function(a,b){ return a -b; });}// 箭头函数的形式const sortNumber = (...numbers) =&gt; numbers.sort( (a,b) =&gt; a - b );console.log(sortNumber([1,3,5,6,56,4554,23,568])); 4、不适合箭头函数的情况：函数声明，执行语句比较多的，还需要用到递归，需要引用函数名，以及事件绑定、解绑定，避免用 箭头函数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"this指向总结& 箭头函数基本形式","date":"2020-10-18T10:57:33.000Z","path":"/posts/3e85b841/","text":"this 指向总结1、默认绑定规则 123456function a(){ 'use strict' console.log(this);} // a(); // 严格模式下是undefined，正常模式下是window 2、隐式绑定：谁调用指向谁 12345678910111213function foo(){ console.log(this.a);// this 是obnj// }var obj = { a:2, foo:foo}// obj.foo(); var bar = obj.foo;var a = 'window'bar(); // -&gt; window.bar(); // this指向window，bar执行时打印 window 3、显示绑定 12345call(obj,a,b,c)apply(obj,[a,b,c])bind(obj,a,b,c) // 前面两个是函数执行，后面的bind是函数体本身 4、new -&gt; 优先级最高 补充：优先级别：new &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 箭头函数的基本形式箭头函数本质上最需要做的一件事情就是this 指向问题。=&gt; 箭头函数 基本形式12var test = () =&gt; {} //箭头函数表达式 第一个形式 参数只有一个参数情况下可以省略括号，return 是一个表达式可以把大括号省略掉 1234567// =&gt;var f = a =&gt; a; // (a) =&gt; a; 这样好看一点// 传统var f = function(a){ return a;} 第二形式 参数不是一个的时候，必须加上括号 123456789let fb = (a,b) =&gt; a+b;// 如果不指定返回值它会返回一个undefinedlet fs = (a,b) =&gt; { var a = 3; var b = 4; console.log(a+b);}console.log(fs()); // 分别输出 7 和undefined 第三种 箭头函数和结构赋值一起使用，函数执行的时候才能解构赋值 12const full = ({first,last} = {}) =&gt; first + '' + last; console.log(full({first:3,last:5})); 箭头函数简单应用12345// 数组排序var arr = [122,34,234,354,3456,3545];var arr1 = arr.sort((a,b)=&gt; a-b);console.log(arr1); 箭头函数的问题在箭头函数里面没有arguments 123456789101112// 在箭头函数里面没有argumentsvar sum = (a,b) =&gt; { console.log(arguments); return a+b; }sum(1,3); // 报错 /**箭头函数并不是用function * 来定义的而是用胖箭头 =&gt; , * 它们本质是两个东西 * =&gt; 函数并不是function的简写或缩写 * **/ spread/rest 运算符(展开或收集)… spread/rest 运算符：用来(展开或收集)ES6新增的语法运算符可以用来替代arguments 123456789101112131415161718var sum = (...args) =&gt; { console.log(args); // 打印出一个真正的数组}sum(1,2); // es5 利用 apply 来模拟 参数是null/undefined不会生效foo.apply(null,[1,2,3,4,5]); //打印1 2 3foo.apply(undefined,[1,2,3,4,5]); //打印1 2 3// 数组展开 // es6 let a = [2 ,3, 4]; let b = [1,...a, 5]; console.log(b); // es5 var a = [2,3,4]; var b = [1].concat(a,[5]); console.log(b) 补充！！！ 不可以通过length找 rest 的长度 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"ES6解构赋值","date":"2020-10-18T09:52:50.000Z","path":"/posts/4783bbff/","text":"概述解构赋值是对赋值运算的扩展。它是一种针对数组或者对象进行模式进行模式匹配，然后对其中的的变量进行赋值。 解构模型在解构中，有下面两部分参与：解构的源，解构赋值表达式的最右边。解构的目标，解构赋值表达式的左边部分。 数组模型的解构基本1234let [a,b,c] = [1,3,4];// a = 1// b = 3// c = 4 可嵌套1234let = [a,[[b],c]] = [1,[2],3];// a = 1// b = 2// c = 3 可忽略123let [a, ,b] = [1,2,3];// a = 1// b = 3 不完全解构1let [a = 1, b] = []; // a = 1, b = undefined 剩余运算符123let [a,...b] = [1,2,3];// a = 1;// b = [1,2] 字符串等在数组的解构中，解构的目标若为可遍历对象，皆可以进行解构赋值。课遍历对象既实现 Iterator 接口数据。 123456console.log(let [a, b, c, d, e] = \"hellos\");// a = 'h'// b = 'e'// c = 'l'// d = 'l'// e = 'o' 解构默认值1234567891011// 例1 let [a = 2] = [undefined]; // a = 2 /* 当解构赋值有匹配结果， 且匹配结果是undefined时， 会触发默认值作为返回结果 */// 例2 let [a = 3,b = a] = []; // a = 3,b = 3 let [a = 3,b = a] = [1] // a = 1, b = 1 let [a = 3,b = a] = [1,2]; // a = 1, b = 2、 例子二a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1a 与 b 正常解构赋值，匹配结果：a = 1，b = 2 对象模型的解构基本123456let { foo, bar } = { foo:'aaa', bar: 'bbb' };// foo = 'aaa'// bar = 'bbb'let { baz : foo } = { baz : 'ddd' };// foo = 'ddd' 可嵌套可忽略12345678910// 可嵌套 let obj = {p: ['hello',{y: 'world'}] }; let {p: [x,{ y }]} = obj; // x = 'hello' // y = 'world'}// 可忽略 let obj = {p: ['hello', {y: 'world'}] }; let {p: [x,{ }] } = obj // x = 'hell 不完全解构1234let obj = {p: [{y,'world'}] };let {p: [{ y },x ] } = obj;// x = undefined// y = 'world' 剩余运算符1234let {a,b,...rest} = {a: 10,b: 20, c:30, d:40};// a = 10// b = 20// rest = {c: 30, d: 40} 解构默认值12345let [a = 10, b = 4] = {a:3};// a = 3; b = 4let {a: aa = 10,b: bb = 5} = {a: 3};// aa = 3; bb = 5; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"块级作用域&let&暂行性死区","date":"2020-10-18T04:19:16.000Z","path":"/posts/dcc531c7/","text":"块级作用域在说块级作用域之前我们先了解函数作用域和全局作用域这个两个东西其实是一个隐式的对象，是访问不到的，在函数执行的前一刻会产生这样一个对象[[scope]],它的第0位如果是在全局的作用域下的话那么存的是GO；如果是在函数的作用域那么执行的前一刻它就会产生相应的AO存在第0位并且把GO挤下去，这个就是作用域的具体概念;里面存储的是就是AO和GO。 预编译的五步： AO： 1、创建AO对象 2、找形参然后找var关键字赋值undefined 3、形参和实参相统一 4、找function 赋值为函数体 5、执行 GO：和上面是一样的 就是没有形参和实参统一 块级作用域的产生在预编译的时候会有一个寻找var的过程，这个过程就是声明提升，声明提升会赋值为undefined或者替换，如果是替换的话就会造成变量的污染;ES5的解决解决方法是立即执行函数；通过封闭自己的作用域解决一部分问题，针对这个现状产生了 let语法 -&gt; 块级作用域概念 let &amp; 暂行性死区为了解决变量污染的问题，针对这个现状产生了let语法。 let特征： let不能在同一作用域下声明123456789/* 这种情况就会报错，a在预编译的时候已经被定义了， 然后let再定义，这种也叫重复定义。*/function test(a){ let a = 10; console.log(a);}test(); let不会声明提升，会产生一个暂时性死区暂时性死区：在let定义之前所定义的变量会产生一个死区。提升范围之前就叫暂时性死区。 12345678910111213141516171819// 以下例子都会报错 // 例1 console.log(a); let a = 10; let b = b; console.log(b); // 例2 function test(x = y, y =2){ /* 这也是一个死区， 先将y赋值给x但y并没有被定义y是在赋值之后才被定义的*/ console.log(x,y); } // 例3 console.log(typeof a); let a; let只在当前的作用域下生效1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 例子1for(;1;){ // 死循环 let a = 1;}console.log(a); // 不会报错// 例子2if(1){ let a = 2;}// 报错，它们不在同一作用域中，访问不到aconsole.log(a);// 例子3for(let i = 0; i &lt; 10; i++){}console.log(i); // 报错// 例子4var arr = [];for(var i = 0; i &lt; 10l i++){ arr[i] = function()[ console.log(i); ]}for(var i = 0; i &lt; 10; i++){ arr[i](); // 打印0-9并不是 两个10 因为 i被覆盖了}// 例子5for(let i = 0; i &lt; 10;i++){ /* 大括号里面的i是在父级作用域()之下的 这两个i并不是相同的i */ let i = 'a'; console.log(i); // 打印十个a}// let 本质就是为js增加一个块级作用域// 例子6if(1){ let a = 11; { /* 如果换成var 的话会被提升到全局, let不会提升 */ let a = 10; console.log(a); //10 } console.log(a); //11} 块级作用域运行嵌套函数声明不推荐这函数声明，建议缓存函数表达式 123456789101112131415161718192021222324// 例1{ function test(){ }}// 例2if(2){ function test(){}}// 例3try{ function test(){}}catch(e){ function test(){}}// 建议写成这样if(2){ // 表达式 var test = function(){}} 块级作用域并没有返回值1234567891011if(1){ return a;}var a = for(;1;){ return 2;}{ return 1;} 补充块级作用域它等于匿名函数的立即调用吗? 这个说法是不准确的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"babel搭建","date":"2020-10-17T12:56:58.000Z","path":"/posts/d624f1ca/","text":"babel:编译工具将ES6语法转化成ES5。babel需要npm包管理器进行安装，npm只能在node环境实现，装了node就安装了npm。 babel安装步骤1、安装node 2、在项目的目录中生成package.json文件 npm init –y 注意：项目目录中不能含又中文名！！！ –y是默认值的package.js,不用的话，在生成过程中会有一大堆问题，我们依次填入就好。 3、安装 babel-cli 用于命令行转码 npm install -g babel-cli 全局安装 npm install –save-dev babel-cli 局部安装根据建议选用局部安装 4、安装转码规则npm install -save-dev babel-preset-es2015 安装完成后想知道是否成功查看package.json中是否生成 5、配置.babelrc在更目录下建立 .babelrc prests是规则，plugins是插件支持，接下来就可以转码了 6、开始开始转码 建立app.js用es6的语法写 npm run build document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"ES6版本过渡历史","date":"2020-10-17T12:50:21.000Z","path":"/posts/4328cb48/","text":"HTML1,HTML2,HTML3 -&gt; 1991-1997 组织 -&gt; IETF(the Internet Enginering Task Force) 国际互联网工程任务组织 HTML3.2 -&gt; 1997.1 W3C -&gt; 万维网联盟 ECMA ECMA-262 ECMAscript 脚本语言规范： 1995 LiveScript --&gt; JavaScript （蹭JAVA的热度） 1996 JavaScript 1.0 1.1； 1997 Jscript -&gt; 网景公司 gg 1997.6 ECMAscript 1.0 发布当初发布的 JavaScript1.1为蓝本 1998.6 ECMAscript 2.0 1999.12 ECMAscript 3.0 -&gt; es5 2000 ECMAscript 4.0 草案并没有通过： 版本太过激进，基本是对3.0的摒弃 组织：TC39（technical committe 39) 2007 ECMAscript 4.0 准备发布，不发布： 除了JavaScript的一小部分的创造支持，其他都不支持 2008.7 ECMAscript 3.1 -&gt; ECMAscript5(改名) 大会(hamony) 实在没有办法迫于舆论发布只在3.0版本做了小幅度改动 版本代号： JavaScript.next JavaScript.next.next 2009.12 ECMAscript5 (正式发布) JavaScript.next -&gt; 放入草案 ES6 JavaScript.next.next -&gt; 放入草案 ES7 2011.6 ECMAscript5.1 2013.3 JavaScript.next(草案冻结) 2013.6 JavaScript.next(草案冻结) 2015.6 ECMAScript6 正式发布： 2000年提出 2015年发布 从这里每年6月份出来新版本升级 ES6 -&gt; ECMAscript2016 ECMAscript2017 ECMAscript2018 小版本改动 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"https://cokesprit.gitee.io/tags/ES6/"}]},{"title":"AJAX","date":"2020-10-17T07:42:22.000Z","path":"/posts/f3334fd0/","text":"AJAX前奏前言:1、浏览器与服务器之间的通信基础是HTTP协议2、用户通过网址或表单向服务器提交请求，服务器向浏览器发送相应的响应。 混编模式： 服务端的代码跟客服端的代码写在一起。例如前端和后端一起写在一个页面里面，文件后缀名必须是后端的那个语言，不能写html，因为html是解析不了服务端的代码的，而php为后缀的页面它是可以嵌入html的代码的。 混编模式的缺点：不好维护、前后端分离比较难。前端程序员：前端程序员是在有了AJAX和异步了以后才有了前后端之分的。 AJAX全称: Asynchronous JavaScript and XML (异步的JavaScript 和 XML)。历史：1999 IE5.0 允许JS脚本向服务器单独发起HTTP请求的新功能2004 Gmail 退出异步邮件更新服务2005 Google Map 异步更新地图服务2005 AJAX被大厂公认命名2005 W3C发布AJAX国际标准 AJAX不是新的编程语言，而是一种使用现有标准的新方法。AJAX是与服务器交互数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 JavaScript异步通信：请求服务器返回JSON/XML文档从前端JSON/XML文档中提取数据，在不刷新整个页面的基础上渲染到相应的位置。 同步请求：点击跳转然后出数据这叫同步异步：异步不刷新页面，不跳转，只请求数据 AJAX主要做向服务器发送一个请求，这个请求是请求一段数据然后服务器就返回这样一段数据，返回来以后我拿到这个数据直接去整理这个数据然后把内容给更新。 创建XMLHttpRequest对象原生AJAX：XMLHttpRequest 对象与 Active 对象 作用：js脚本HTTP请求的发起必须通过XMLHttpRequest对象也是通过AJAX进行浏览器与服务器通信的接口不局限于XML，可以发送任何格式的数据。 XMLHttpRequest本身是一个JS引擎内置的构造函数所有XMLHttpRequest对象都需要被实例化 var xhr = new XMLHttpRequest。 兼容性：IE5/IE6 使用Active对象var xhr = new ActiveXObject(‘Micrsoft.XMLHTTP’); JavaScript 123456789// 兼容性写法var xhr ;if(window.XMLHttpRequest){ xhr = new XMLHttpRequest();}else{ xhr = new ActiveXObject('Mcisoft.XMLHTTP');}console.log(xhr); AJAX发送HTTP请求实例化出来的xhr有两个方法：open() 发送设置：参数：open(method,url,async)method: 请求方式url: 请求发送的地址async: false同步 true异步，建议都用ture send()发送请求：参数：发送POST请求体用数据，GET请求不用填写。 AJAX-发送请求时的响应状态onreadyStatechange事件：挂载到XMLHttpRequest对象上的事件。每当readyState改变时，就会触发onreadystatechange事件 readyState状态：通过XMLHttpRequest对象发送HTTP请求的各阶段状态(0-4)0：请求未初始化1：服务器连接一建立2：请求以接收3：请求处理中4：请求已完成，且响应已就绪 注释：onreadystatechange 事件被触发5次(0-4),对应着readyState的每个变化。 status状态：服务器响应的状态码200:”OK”400:”未找到页面” 当readyState等于4且状态为200时，表示响应以就绪。 responseText 属性获得字符串形式的响应数据语法：xhr.responseText responseXML 属性获得XML形式的响应数据语法：xhr.responseXML AJAX-POST请求方式的主要事项 POST请求方式下，send方法参数中的格式：a=1&amp;b=2&amp;c=3 xhr.setRequestHeader(‘Content-Type’,’application/X-www-from-urlencoded’);POST请求必须设置这个请求头信息，目的是请求体中的数据转化为键值对，这样后端a=1&amp;b=2&amp;c=3这样的数据才知道这是一个POST方式传来的数据 还有一点xhr.open是在xhr.send前面设置才有用 ajax的三种方式这三种都基于jQuery在使用的时候要引入jQueryJavaScript 12345678910111213141516171819202122232425// 第一种 $.ajax({ url:\"http://localhost:8086/myItem/class/data/data.json\", // 请求地址 type:'POST', // 请求方式 dataType: 'JSON', data: { // 数据体 status: 1 }, // 成功之后的回调函数 success:function(data){ console.log(data); } });// 第二种 $.post(\"http://localhost:8086/myItem/class/data/data.json\", {stadus: 1},function(data){ console.log(data); });// 第三种 $.get('http://localhost:8086/myItem/class/server/get_coursesajax.php?status=1', function(data){ console.log(data); }); 原生AJAX请求数据12345678910111213141516171819202122232425262728293031var xhr;// 1、创建HttpRequest对象if(window.XMLHttpRequest){ xhr = new window.XMLHttpRequest();}else{ xhr = new ActiveXObject('Mcisoft.XMLHTTP');}console.log(xhr.readyState); // 输出各个阶段的状态码// 2、配置请求发送xhr.open(\"GET\",\"http://localhost:8086/myItem/class/server/get_coursesajax.php?status=1\",true);// 3、发送xhr.send(); // 发送HTTP请求console.log(xhr.readyState);// 4、监听请求的状态和响应的状态xhr.onreadystatechange = function(){ console.log(xhr.readyState); // 监听请求的状态和响应的状态 if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){ console.log(xhr.responseText); // 返回的是json字符串 // 5、接到响应的数据 console.log(JSON.parse(xhr.responseText)); // 使用JSON.parse 把json字符串解析成JSON对象 }} 运行结果： AJAX封装JavaScript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 var xhr = (function(){ var o = window.XMLHttpRequest? new XMLHttpRequest: new ActiveXObject('Microsoft.XMLHTTP'); // 如果浏览器的版本是IE5或者IE4时 if(!o){ throw new Error('您的浏览器不支持异步发起HTTP请求'); } function _doAjax(opt){ var opt = opt || {}, type = (opt.type || 'GET').toUpperCase(), //获取方式都转化为大写 async = opt.async || true, url = opt.url, data = opt.data || null, // 如果是GET请求data就等于null error = opt.error || function(){}, success = opt.success || function(){}, complete = opt.complete || function(){}; // 无论成功还是失败这个函数都执行 // 如果url没配置的话就抛出异常 if(!url){ throw new Errow('您没有填写URL'); } o.open(type,url,async); // 如果是post才设置 type === 'POST' &amp;&amp; o.setRequestHeader('Content-type','application/x-www-form-urlencoded'); o.send(type === 'GET' ? null : formatDatas(data)); o.onreadystatechange = function(){ if(o.readyState === 4 &amp;&amp; o.status === 200){ success(JSON.parse(o.responseText)); } if(o.status === 400){ error(); } complete(); // 无论成功还是失败这个函数都执行 } } // 将对象转成成 status=1&amp;flag=2 这种格式 function formatDatas(obj){ var str = ''; for(var key in obj){ str += key + '=' + obj[key] + '&amp;'; } return str.replace(/&amp;$/,''); // 写一个正则表达式判断最后面一个是不是&amp; } return { ajax:function(opt){ _doAjax(opt); }, post:function(url,data,callback){ _doAjax({ type:'POST', url: url, data:data, success: callback }); }, get:function(url,callback){ _doAjax({ type:'GET', url:url, success:callback }) } }})(); 使用ajax 1234567891011121314151617181920212223242526// 使用xhr.ajax xhr.ajax({ type:'POST', url:'http://localhost:8086/myItem/class/server/get_courses.php', data:{ status:1, flag:2 }, success:function(data){ console.log(data); } });// 使用xhr.post xhr.post('http://localhost:8086/myItem/class/server/get_courses.php',{ status:1, flag:2 },function(data){ console.log(data); });// 使用xhr.getxhr.get('http://localhost:8086/myItem/class/server/get_coursesajax.php?status=1&amp;flag=2',function(data){ console.log(data);}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://cokesprit.gitee.io/tags/AJAX/"}]},{"title":"JSON基础、方法","date":"2020-10-17T02:35:55.000Z","path":"/posts/987b192d/","text":"什么是JSONJSON全称是“JavaScript Object Notation”,是JavaScript对象的延伸;为了数据交互存在。JSON特点：选用映射模式来形成比较轻量级的数据结构。JSON一定是对象但是JavaScript的对象就不一定是JSON。 JSON的书写格式1.映射用冒号隔开2.并列数据用逗号隔开3.映射的集合用{}包裹4.键名一定要有双引号5.并列数据集合用[]包裹 JavaScript 12345678910111213141516171819202122232425262728293031323334// 1、映射用冒号隔开 var str1 = { \"name\":\"张三\" }// 2、并列数据用逗号隔开 var str2 = { \"name\":\"张三\", \"age\":18 }// 3、映射的集合用 var str3 = { \"name\": \"张三\", \"age\": 22 }//4、键名一定要用双引号 var str4 = { \"name\":\"张三\", \"age\": 22 } //5、 并列数据集合用[]包裹 var str5 = [ { \"name\": \"张三\", \"age\": 18 }, { \"name\": \"李四\", \"age\": 22 } ]; JSON方法JSON.parse(text,reviver)将JSON字符串转化成JSON对象text:必需,一个有效的 JSON 字符串。reviver:可选，一个转换结果的函数， 将为对象的每个成员调用此函数。 JSON.stringify()将JavaScript对象转换成JSON字符串。可以将JavaScript数组转换成JSON,不能保存Date对象，JSON.stringify() 会将所有日期转换为字符串。 例子 123456789101112131415161718192021222324252627282930313233 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 注意键名一定要用双引号 --&gt; &lt;div data-info='{\"name\":\"张三\",\"age\":25}'&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var oDiv = document.getElementsByTagName('div')[0]; var info = oDiv.getAttribute('data-info'); // 将数据转化为JavaScript对象 var jsonData = JSON.parse(info); console.log(jsonData); var oDivtwo = document.getElementsByTagName('div')[1]; var obj = { \"name\":\"王五\", \"age\":18 } // 将JavaScript对象转换成JSON字符串 var str = JSON.stringify(obj); oDivtwo.setAttribute('data-info',str); console.log(str); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果： 补充实际上最早期的时候不是用JSON，而是用XML来做数据交互的而是用自定义标签，不过 -&gt; 解析难度大，损耗性能。XML数据文档很大、不宜阅读、解析难度比较复杂。现在XML还是有在用的服务器端与服务器通信的时候，做数据交互的时候XML用的还比较多的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSON","slug":"JSON","permalink":"https://cokesprit.gitee.io/tags/JSON/"}]},{"title":"鼠标行为坐标系、pageXY封装、拖拽函数封装","date":"2020-10-14T15:03:06.000Z","path":"/posts/ed50b3e1/","text":"鼠标行为 -&gt; 坐标系clientX/Y 鼠标位置相对于当前可视区域的坐标（不包括滚动条的位置） pageX/Y 鼠标位置相对于当前文档的坐标（包含滚动条的距离 IE9以下不支持） layerX/Y 同pageX/Y相同但是 IE11以下同clientX/Y相同（不推荐使用） screenX/Y 鼠标位置相对于屏幕的坐标 offsetX/Y 鼠标位置相对于有定位的父级元素的坐标（包含边框，但是safari不包括边框） JavaScript 12345678document.onclick = function(e){ var e = e || window.event; console.log(\"clientX:\"+e.clientX, \"layerX:\"+e.layerX, \"screenX:\"+e.screenX, \"offsetX:\"+e.offsetX, \"pageX:\"+e.pageX); } 封装pageXY封装在使用pageX/Y获取鼠标相对于当前文档的坐标的时它会包含滚动条的距离且IE9以下不支持。为了解决这些问题我们对pageXY进行封装。 JavaScript 1234567891011121314151617181920212223242526272829303132function pagePos(e){ var sLeft = getScrollOffset().left, //获取滚动条滚动的距离 sTop = getScrollOffset().top; var cLeft = document.documentElement.clientLeft || 0, cTop = document.documentElement.clientTop || 0; /** 通过document.documentElement.clientLeft/Top可以获得偏移量（既margin) */ return { // 鼠标相对于可视区的距离 + 滚动条滚动的距离 + 偏移量的距离(margin) X: e.clientX + sLeft - cLeft, Y: e.clientY + sTop - cTop } } // 获取滚动条滚动距离 function getScrollOffset(){ if(window.pageXOffset){ return { left: window.pageXOffset, top: window.pageYOffset } }else{ return { left: document.body.scrollLeft + document.documentElement.scrollLeft, top: document.body.scrollTop + document.documentElement.scrollTop } } } 拖拽函数封装/** 真正的拖拽并非那么简单，首先得知道三个东西 mousedown moueup mousemove 鼠标按下 鼠标抬起 鼠标移动 鼠标按下并且移动应该怎么写呢？ 是不是应该把鼠标移动的事件处理函数， 写到鼠标按下的事件处理函数的内部才行。 / JavaScript 1234567891011121314151617181920212223242526272829303132333435var box = document.getElementsByClassName('box')[0];elemDrag(box);function elemDrag(elem){ var x , y; addEvent(elem,\"mousedown\",function(e){ // 鼠标当前点击的X坐标 // 左外边距 x = pagePos(e).X - getStyles(elem,'left'); y = pagePos(e).Y - getStyles(elem,'top'); addEvent(document,\"mousemove\",mouseMove); addEvent(document,\"mouseup\",mouseUp); // 阻止冒泡和 默认事件 cancelBubble(e); preventDefaultEvent(e); }); function mouseMove(e){ var e = e || window.event; elem.style.top = pagePos(e).Y - y + 'px'; elem.style.left = pagePos(e).X - x + 'px'; } function mouseUp(e){ var e = e|| window.event; removeEvent(document,\"mousemove\",mouseMove); removeEvent(document,\"moseup\",mouseUp); }} 以上就是拖拽函数的封装但是并不完整 -&gt; 还差判断边界 注意：addEvent()、pagePos()、getStyles()、cancelBubble()、preventDefaultEvent()需要自己封装，在下一篇章会补充。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"冒泡捕获流、事件与事件源对象、事件委托","date":"2020-10-05T11:49:12.000Z","path":"/posts/1513f4a4/","text":"事件流事件流：描述页面中接收事件的顺序和冒泡捕获有关。 事件流分为两种：事件冒泡流：是IE提出来的时间冒泡流 Event Bubbing。事件捕获流：网景公司 Netscape 提出来的事件捕获流 Event Capturing。 事件流的三个阶段：事件捕获阶段 -&gt; 处于目标阶段 -&gt; 事件冒泡阶段 捕获是处于：事件捕获阶段冒泡是处于：事件冒泡阶段 事件与事件源对象事件 其他浏览器：Event对象 = new MouseEvent(); IE浏览器：window.event IE浏览器不是传递到事件处理函数的参数里面的而是传到一个全局的window.event对象里面。 输出mouseEventhtml 1234567891011121314151617181920212223242526272829 &lt;style&gt; .wrapper{ width:200px; height: 200px; background-color: green; font-size: 18px; color:#fff; } .wrapper .outer{ width:150px; height: 150px; margin-left:200px; background-color: red; } .wrapper .outer .inner{ width:100px; height:100px; margin-left: 150px; background-color: orange; } &lt;/style&gt;&lt;div class=\"wrapper\"&gt; wrapper &lt;div class=\"outer\"&gt; outer &lt;div class=\"inner\"&gt;inner&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JavaScript 1234567var wrapper = document.getElementsByClassName('wrapper')[0];warpper.onclick = function(e){ var e = e || window.event; console.log(e);} 运行结果： 事件源对象输出e的时候可以在MouseEvent查找到 target 和 scrElement 这两个事件源对象。 火狐：只有targetIE：只有srcElements 使用上面的html结构分别点击这三个盒子输出事件源对象： JavaScript 1234567wrapper.onclick = function(e){ var e = e || e.window.event; console.log(\"点击了\"+e.target.className+\"盒子\"); console.log(e.target); console.log(e.srcElement);} 运行结果： 事件源的兼容性写法 123456wrapper.onclick = function(e){ var e = e||window.event; var tar = e.target || e.srcElement; console.log(tar);} 事件委托事件委托也叫事件代理：意思是我不亲自绑定点击事件，我把事件委托给我的父级，让父级去触发，触发以后通过事件源对象来找到我点击的元素。好处不用循环添加事件，性能更加好。 例子：写一个列表当点击”添加li”按钮时就会在列表末尾处新增一个li并且添加上序号,当点击相应的li时输出下标输出当前li的下标。 html 123456789&lt;button&gt;点击添加li&lt;/button&gt;&lt;ul class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt;&lt;/ul&gt; JavaScript 123456789101112131415161718192021var oList = document.getElementsByClassName('list')[0], oLi = oList.getElementsByTagName('li'), oBtn = document.getElementsByTagName('button')[0]; // 点击button添加li oBtn.onclick = function(e){ var li = document.createElement('li'); li.innerHTML = oLi.length + 1; oList.appendChild(li); } // 给ul添加点击事件 oList.onclick = function(e){ var e = e || window.event; var tar = e.target || e.srcElement; var index = Array.prototype.indexOf.call(oLi,tar); console.log(index); } // Array.prototype.indexOf.call(DOM对象集合,当前事件源); 原理解析：当点击li的时候，冒泡到ul,ul正好触发点击事件因为ul绑定了点击事件，然后触发了就可以找到事件对象，找到事件对象之后就能找到事件源，找到事件源之后再使用Array.prototype.indexOf和oLi就能找到当前点击的li的下标了。这就是使用事件委托拿下标。 Array.prototype.indexOf.call(DOM对象集合,当前事件源); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"事件处理处理函数、冒泡捕获、阻止冒泡默认事件","date":"2020-10-04T12:18:59.000Z","path":"/posts/e57a545c/","text":"事件：吃饭事件触发 -&gt; 长胖onclick = function(){}事件 + 事件的反馈 = 前端交互 交互体验 事件处理函数句柄绑定句柄绑定的几个组成部分别是句柄、事件句柄、事件源，下面例子描述它们是那些部分。 12345678910111213oDiv.onclick = function(){ this.style.backgroundColor = \"red\";}// 句柄：onclick/* 事件句柄 onclick = function(){ this.style.backgroundColor = \"red\"; }*/// 事件源：事件作用在哪个元素身上谁就是事件源 如何绑定事件处理函数句柄的绑定 elem.onclick = function(){}句柄绑定方式兼容性最好。 内联事件监听器 1&lt;div onclick = \"test()\"&gt;&lt;/div&gt; addEventListener 语法: elem.addEventListener(事件类型,事件处理函数,false); 12345678oDiv.addEventListener('click',function(){ console.log(1);},false)/** 这种IE9及以下不兼容，但是它是W3C规范，有点可疑帮到你多个事件处理函数。解决IE9及以下不兼容使用elem.attachEvent(事件类型,事件处理函数);*/ attachEvent这种是IE8及以下的绑定方式 elem.attachEvent(事件类型,事件处理函数);注意谷歌是没有这个方法的。attachEvent的this是指向window的解决方案是使用call/apply 1234567891011121314oBtn.attchaEvent('onclick',function(){ // this是执向 -&gt; window 并不是当前这个对象！！！ oBtn.innerHTML = '加载中....'; // 让this指向oBtn this.call(oBtn);});// 打印两遍oDiv.attachEvent('onclick',test);oDiv.attachEvent('onclick',test);function test(); 封装事件处理函数真正在企业开发的时候是很少使用上面那几种方式来绑定事件处理函数的我们要先对它们来进行封装了之后再使用。 addEvent 123456789101112131415161718var oBtn = document.getElementsByTagName('button')[0]; addEvent(oBtn,'click',function(){ console.log(1); });// 事件处理函数 function addEvent(el,type,fn){ if(el.addEventListenner){ // fn是函数的缩写 el.addEventListenner(type,fn,false); }else if(el.attachEvent){ el.attachEvent('on'+type,function(){ fn.call(el); }); }else{//如果两个都不支持就只能使用on el['on'+ type] = fn; }} 解除事件处理函数有如下几种方案:第一种：elem.onclick = null/false;第二种：element.removeEventListener(‘click’,test,false);第三种：element.detachEvent(‘onclick’,test); 例子：领取优惠券当点击领取优惠券只有按钮变成灰色,且不可以再使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;领取优惠券&lt;/title&gt; &lt;style&gt; button{ outline: none; border: none; width:100px; height: 50px; background-color:red; color: #fff; } .got{ background-color: #ddd; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;领取优惠券&lt;/button&gt; &lt;script&gt; var oBtn = document.getElementsByTagName('button')[0]; // 第一种 // oBtn.onclick = function(){ // this.className = ' got'; // this.innerHTML = '已领取'; // this.onclick = null; // } // 第二种 oBtn.addEventListener('click',test,false); function test(){ this.className = 'got'; this.innerHTML = '已领取'; this.removeEventListener('click',test,false); } // 第三种 -&gt; IE8及以下 // oBtn.attachEvent('onclick',test1); // oBtn.detachEvent('onclick',test1); // function test1(){ // this.className = 'got'; // this.innerHTML = '已领取'; // } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 冒泡捕获事件冒泡:是向上 -&gt; 子级向父级传递，子元素触发事件的同时，会向父级元素一层一层传递事件冒泡，只要父元素有相同的事件类型，父级的事件就会被触发。 事件捕获:是向下 -&gt; 当子元素触发事件由父元素一层一层的向子元素传递这时的点击事件就叫事件捕获。嵌套关系最顶层的父级元素开始捕获事件，直到事件源（谁触发事件谁就是事件源）的子元素这个捕获就结束了。 例子html 12345678910111213141516171819202122232425262728&lt;style&gt; .wrapper{ width:200px; height:200px; background-color:green; font-size: 20px; color: #fff; } .wrapper .outer{ width:150px; height: 150px; margin-left:200px; background-color: red; } .wrapper .outer .inner{ width:100px; height:100px; margin-left: 150px; background-color: orange; }&lt;/style&gt;&lt;div class=\"wrapper\"&gt; wrapper &lt;div class=\"outer\"&gt; outer &lt;div class=\"inner\"&gt;inner&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JavaScript 1234567891011121314151617181920212223242526272829 var wrapper = document.getElementsByClassName('wrapper')[0], outer = document.getElementsByClassName('outer')[0], inner = document.getElementsByClassName('inner')[0], body = document.getElementsByTagName('body')[0]; wrapper.addEventListener('click',function(){ console.log('wrapper冒泡'); },false); // 默认是冒泡，true是捕获 outer.addEventListener('click',function(){ console.log('outer冒泡'); },false); inner.addEventListener('click',function(){ console.log('inner冒泡'); },false);// 可以即绑定冒泡事件又绑定捕获事件 wrapper.addEventListener('click',function(){ console.log('wrapper捕获'); },true); outer.addEventListener('click',function(){ console.log('outer捕获'); },true); inner.addEventListener('click',function(){ console.log('inner捕获'); },true); 当点击inner盒子时控制台输出： 总结: 先捕获后冒泡，如果既不是捕获又不是冒泡就按执行顺序。记住事件源是不存在任何捕获和冒泡的，只要不存在捕获和冒泡就是按照绑定执行处理函数的顺序来执行的。 没有捕获和冒泡现象的事件focus blur change submit reset select 阻止冒泡/捕获现象有两种阻止冒泡/捕获事件，建议将它们封装了之后再使用 W3C: e.stopPropagation()IE: e.cancelBubble = ture e是存放在事件处理函数的参数里面的，但是IE8以前是存在window上的所以IE8: window.event html 123456789101112131415161718192021&lt;style&gt; .wrapper{ position: relative; width:200px; height: 200px; background-color: green; } .apply{ position: absolute; bottom:15px; right: 15px; height: 30px; line-height: 30px; padding: 0 10px; background-color: red; color: #fff; }&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;div class=\"apply\"&gt;立即申请&lt;/div&gt;&lt;/div&gt; JavaScript 123456789101112131415161718192021var wrapper = document.getElementsByClassName('wrapper')[0], apply = document.getElementsByClassName('apply')[0];wrapper.addEventListener('click',function(){ console.log('详情'); },false);apply.addEventListenner('click',function(e){ /* e是存放在事件处理函数的参数里面的，但是 IE8及以下是存在window上的 所以IE8: window.event */ var e = e || window.event; //兼容性赋值 // 第一种 e.stopPropagation(); // 第二种 // e.cancelBubble = true; console.log(\"已申请\");},false); 当点击立即申请时： 父级的事件并没有被触发 封装取消冒泡/捕获123456789function cancelBubble(e){ var e = e || window.event; if(e.stopParpagation){ e.stopParpagaton(); }else{ e.cancelBulle = true; }} 阻止默认事件第一种：return false; 这种兼容性最好，然而只能在句柄的方式使用。第二种：e.preventDefult(); 但IE9及以下不支持。第三种：e.returnValue = false; IE9及以下的阻止默认事件的写法。 阻止a标签默认事件的几种写法： 123456789&lt;a href=\"JavaScript:;\"&gt;百度一下&lt;/a&gt;&lt;!-- void(0) -&gt; return 0 --&gt;&lt;a href=\"JavaScript:void(0);\"&gt;淘宝&lt;/a&gt; &lt;!-- 这种是锚点 --&gt;&lt;a href=\"\"&gt;网易云&lt;/a&gt;&lt;a href=\"\" class=\"qm\"&gt;QQ音乐&lt;/a&gt; JavaScript 12345678910111213var qmusic = document.getElementsByClassName('qm')[0];qmusic.onclick = function(e){ var e = e||window.event; e.preventDefault();}// 取消文本菜单 鼠标右击的时候document.addEventListener('contextmenu',function(e){ var e = e || window.event; e.preventDefault(); },false); 面试单击li时输出li的index html 1234567&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; JavaScript 12345678910111213var oLi = document.getElementsByTagName('li');var len = oLi.length,item;for(var i = 0; i &lt; len; i++){ (function(i){ item = oLi[i]; item.addEventListener('click',function(){ console.log(i); },false); }(i));} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"读写样式属性、操作伪元素、元素运动初探","date":"2020-10-04T01:47:00.000Z","path":"/posts/4e2086c7/","text":"首先我们要知道DOM是不可以直接操作css样式表的,也不能直接访问它是通过操作标签里面的style属性然后改变元素的样式。 读写样式属性elem.style.xxxelem.style.xxx这种方式是操作元素的style属性来改变样式写法: 小驼峰写法 值 -&gt; 字符串 复合值拆解赋值 保留值前面加css JavaScript 12345678910111213141516var oDiv = document.getElementsByClassName('oDiv')[0];oDiv.style.position = 'absulute';oDiv.style.left = '200px';oDiv.style.top = '300px';// oDiv.style.border = '5px solid pink\"; // 复合值// 复合值拆解 -&gt; 这样写效率更高oDiv.style.borderWidth = '5px';oDiv.style.borderColor = 'pink';oDiv.style.borderStyle = 'solid';// 保留值 -&gt; 前面加cssoDiv.style.cssFloat = 'left'; window.getComputedStyle查看计算样式 -&gt; 只读计算样式：它都会把样式的属性缓存绝对值语法:window.getComputedStyle(elem,null)[prop];括号里面的null是写填写伪元素这样方便我们获取伪元素的相关属性了。例子:window.getComputedStyle(oDiv,”after”).width; 注意：IE8及以下不支持getComputedStyle(),IE8及以下写elem.currentStyle[prop],为了更方便的使用我们得对它们两进行兼容性封装。 兼容性封装 -&gt; getStyle JavaScript 12345678910111213141516function getStyle(elem,prop){ if(window.getComputedStyle){ if(prop){ return window.getComputedStyle(elem,null)[prop]; }else{ //如果prop不存在就返回一个集合 return window.getComputedStyle(elem,null); } }else{ if(prop){ return window.currentStyle[prop]; }else{ return window.currentStyle; } }} 好处：兼容性封装 -&gt; 可以避免 offsetWidth/offsetHeight, 它们两个是到渲染引擎里面访问宽高,但是它会把padding算上。 操作伪元素html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;操作伪元素&lt;/title&gt; &lt;style&gt; .box{ width: 100px; height: 100px; border: 2px solid #2980b9; background-color: #3498db; } .box::after{ content:\"\"; display: block; width: 50px; height: 50px; background-color:#18dcff; } /* 建议这种写法 */ .box.active::after{ transition: 0.5s; background-color: #ffcccc; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;script&gt; var box = document.getElementsByClassName('box')[0]; box.onclick = function(){ // 建议这种写法 this.className += ' active'; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运算运动初探制作下拉菜单 html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;制作下拉菜单&lt;/title&gt; &lt;style&gt; a{ text-decoration: none; } ul{ padding:0; margin:0; list-style:none; } .dropdown{ position: relative; width: 200px; height: 50px; background-color: #000; color: #fff; } .dropdown::after{ content: \"\"; display:table; position: absolute; right:15px; top: 18px; width: 15px; height: 15px; background-image: url(img/down.png); background-size: 100% 100%; background-repeat: no-repeat; } .dropdown.up::after{ background-image:url(img/top.png) } .dropdown .list{ height: 0; overflow: hidden; } .dropdown a{ display: block; } .dropdown .main{ height: 100%; text-align:center; line-height: 50px; color: #fff; } .dropdown .item{ height: 40px; background-color: #333; } .dropdown .item:hover{ background-color: #000; } .dropdown .item a{ height: 100%; color: #999; text-align: center; line-height: 40px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"dropdown\"&gt; &lt;a href=JavaScript:; class=\"main\"&gt;下拉菜单&lt;/a&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item\"&gt;&lt;a href=\"\"&gt;这是一个项目&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item\"&gt;&lt;a href=\"\"&gt;这是二个项目&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item\"&gt;&lt;a href=\"\"&gt;这是三个项目&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item\"&gt;&lt;a href=\"\"&gt;这是四个项目&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item\"&gt;&lt;a href=\"\"&gt;这是五个项目&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var dropdown = document.getElementsByClassName('dropdown')[0], oList = elemChildren(dropdown)[1], timer = null listHeight = 0, spend = 2; // 每一次增加两个像素 // 鼠标移入 dropdown.onmouseenter = function(){ clearInterval(timer); timer = setInterval(function(){ if(listHeight &gt;= 200){ clearInterval(timer); }else{ listHeight = parseInt(getStyle(oList,'height')) + spend; oList.style.height = listHeight + 'px'; } },1); this.className += ' up'; } // 鼠标移出 dropdown.onmouseleave = function(){ clearInterval(timer); timer = setInterval(function(){ if(listHeight &lt;=0){ clearInterval(timer); }else{ listHeight = parseInt(getStyle(oList,'height')) - spend; oList.style.height = listHeight + 'px'; } },1); this.class = ' dropdown'; } // 查找子元素 function elemChildren(node){ var temp = { 'length':0, 'push':Array.prototype.push, 'splice':Array.prototype.splice }, children = node.childNodes, len = children.length, item ; for(var i = 0; i &lt; len; i++){ item = children[i]; if(item.nodeType === 1){ temp.push(item); } } return temp; } function getStyle(elem,prop){ if(window.getComputedStyle){ if(prop){ return window.getComputedStyle(elem,null)[prop]; }else{ return window.getComputedStyle(elem,null); } }else{ if(prop){ return elem.currentStyle[prop]; }else{ return elem.currentStyle; } } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 作业实现一个无缝轮播 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"offsetLeft/offsetTop/offsetParent","date":"2020-09-23T01:22:04.000Z","path":"/posts/a2c7835c/","text":"JavaScript Element offsetLeft/offsetTop属性返回相对于offsetParent元素左/右侧的的左/右侧位置（以像素为单位）。返回值包括：左/右侧位置和元素的边距左/右侧填充，滚动条和offsetParent元素的边框 JavaScript Element offsetParent属性返回最近有定位的祖先。 注意:offsetParent与offsetLeft和offsetTop属性一起使用。 案例html 1234567891011121314151617181920212223242526272829303132 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;offsetLeft/offsetTop/offsetParent&lt;/title&gt; &lt;style&gt; body{ margin: 0; } .parent{ width: 300px; height: 300px; margin: 100px; background-color:#999; overflow: hidden; } .son{ width: 100px; height: 100px; margin: 100px; background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"son\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 12345678var son = document.getElementsByclass('son')[0];/* offsetLeft/offsetTop 只认它父级的定位元素 如果父级没有定位元素它就往上找，如果都没有的话那就找body*/console.log(son.offsetLeft);console.log(son.offsetTop);console.log(son.offsetParent); // body 运行结果： 自己相对于整个文档的位置我能不能直接找到我自己相对于整个html文档的位置？不管我的父级元素有没有定位。 JavaScript 1234567891011121314151617181920function getElemDoPosition(el){ var parent = el.offsetParent, // 找到自己的父元素 // 距离有定位父级的坐标 offsetLeft = el.offsetLeft, offsetTop = el.offsetTop; // 如果parent存在那么就一定是定位元素 while(parent){ offsetLeft += parent.offsetLeft; offsetTop += parent.offsetTop; parent = parent.offsetParent; } return { left: offsetLeft, top: offsetTop }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BOM","slug":"BOM","permalink":"https://cokesprit.gitee.io/tags/BOM/"}]},{"title":"getBoundingClientRect","date":"2020-09-22T08:42:39.000Z","path":"/posts/b7620653/","text":"Element.getBoundingCligClientRect()方法返回元素的大小及其相对于视口的位置。如果是标准盒子模型，元素的尺寸等于width/height + padding + border-width的总和。如果box-sizing: border-box，元素的的尺寸等于 width/height。 html 123456789101112131415161718192021222324252627282930 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;getBoundingClientRect&lt;/title&gt; &lt;style&gt; .box{ position: absolute; top:100px; left: 100px; width:100px; height: 100px; background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;script&gt; var box = document.getElementsByClassName('box')[0]; /*ie浏览器宽度和高度不答应出来 , 不打印的话：width = rigth - left, top = buttom - top*/ var info = box.getBoundingClientRect(); console.log(info); // getBoundingClientRect 这个基本不用 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BOM","slug":"BOM","permalink":"https://cokesprit.gitee.io/tags/BOM/"}]},{"title":"获取整个html文档的宽高","date":"2020-09-22T07:21:47.000Z","path":"/posts/20ad7b61/","text":"获取整个html文档的宽高:document.body.scrollHeight/scrollWidthdocument.documentElement.scrollHeight/scrollWidth scrollHeight/scrollWidth 到底是什么？ scrollWidth === window.innerWidth + window.pageXOffset; 获取整个html文档宽高由于某些浏览器是不支持document.body.scrollWidth/scrollHeight的所以要封装起来。 JavaScript 1234567891011121314function getScrollSize(){ // 如果document.body.scrollWidth存在 if(document.body.scrollWidth){ return{ width: document.body.scrollWidth, height: document.body.scrollHeight } }else{ return{ width:document.documentElement.scrollWidth, height: document.documentElement.scrollHeight } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BOM","slug":"BOM","permalink":"https://cokesprit.gitee.io/tags/BOM/"}]},{"title":"获取浏览器可视区域的尺寸","date":"2020-09-22T06:37:27.000Z","path":"/posts/abb398ff/","text":"获取浏览器可视区域既窗口的宽高常规的写法：window.innerWidth/innerHeight ie9/ie8及以下的写法：标准模式：document.documentElement.clienWidth/clienHeigth怪异模式：document.body.clienWidth/clientHeight 其他写法：outerWidth/outerHeight 它们会包括一些浏览器的工具栏，了解即可。 获取可视区域封装JavaScript 12345678910111213141516171819202122function getViewportSize(){ if(window.innerWidth){ return{ width: window.innerWidth, height: window.innerHeight } }else{ // 如果是怪异模式 if(document.compatMode === \"BackCompat\"){ return{ width:document.body.clientWidth, heigth: document.body.clientHeight } }else{ return { // 这两个不包括滚动条，以上都包括 width: document.documentElement.clientWidth, height: document.documentElement.clientHeight } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BOM","slug":"BOM","permalink":"https://cokesprit.gitee.io/tags/BOM/"}]},{"title":"浏览器的兼容性模式","date":"2020-09-22T03:26:21.000Z","path":"/posts/cbc93df7/","text":"浏览器的兼容性模式分为标准模式和怪异模式标准模式:在顶部加上&lt;!DOCTYPE html&gt;就变成标准模式。怪异模式:把&lt;!DOCTYPE html&gt;注释掉就会切换到怪异模式,怪异模式 -&gt; 向后兼容五个版本。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BOM","slug":"BOM","permalink":"https://cokesprit.gitee.io/tags/BOM/"}]},{"title":"查看滚动条距离与高度","date":"2020-09-22T01:57:43.000Z","path":"/posts/6ad09b7c/","text":"查看滚动条的方式有分为两种一种是比较常见的，另一种是不常见的。 比较常见:window.pageXOffset/window.pageYOffsetie9某一些版本及ie8以下不支持。ie9/ie8及以以下的写法：document.body.scrollLeft/scrollTopdocument.documentElement.scrollLeft/scrollTop 不常见:window.scrollX/scrollY 浏览器兼容情况下面分别为标准模式（s） 和 怪异模式（b），在下一篇详细的讲什么是标准模式和怪异模式。 结论:从图中很清楚的看到document.body可以使用,那么document..documentElement就不可以使用，反之也是如此。 滚动条兼容性封装为了解决上述所出现的兼容性问题，我们将这些方法封装成一个功能模块，来解决这个问题。 获取滚动条滚动距离JavaScript 12345678910111213141516function getScrollOffset(){ // 如果window.pageXOffset不为空 if(window.pageXOffset){ return { left: window.pageXOffset, top: window.pageYOffset } }else{ return{ /* 因为document.body或document.documentElement 不可用时就会是空，所以这样写可以。*/ left: document.body.scrollLeft + document.documentElement.scrollLeft, top: document.body.scrollTop + document.documentElement.scrollTop } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BOM","slug":"BOM","permalink":"https://cokesprit.gitee.io/tags/BOM/"}]},{"title":"日期对象","date":"2020-09-20T11:44:54.000Z","path":"/posts/64d914d6/","text":"JavaScript Date对象用于处理日期和时间，Date对象会自动把当前日期和时间保存为其初始化值。 Date对象的常用方法getDate()getDate() 放回当前是以一个月的第几天 1-31 返回几号 JavaScript 123var date = new Date();var getDate = date.getDate();console.log(getDate); getDay()getDay()返回当前是一周中的第几天 0 - 6，星期天是第一天 ，返回 0 是星期天。 JavaScript 123456789101112131415161718192021222324252627282930Date.prototype.getWeekDay = function(lang){ var day = this.getDay(); switch(day){ case 0: return lang === 'chs' ? '星期天' : 'Sunday'; break; case 1: return lang === 'chs' ? '星期一' : 'Monday'; break; case 2: return lang === 'chs' ? '星期二' : 'Tuesday'; break; case 3: return lang === 'chs' ? '星期三' : 'Wednesday'; break; case 4: return lang === 'chs' ? '星期四' : 'Thursday'; break; case 5: return lang === 'chs' ? '星期五' : 'Friday'; break; case 6: return lang === 'chs' ? '星期六' : 'saturday'; break; }}var date = new Date();console.log(date.getWeekDay('chs')); getMonth()getMonth()返回当前为第几个月 0 -11 JavaScript 12var date = new Date();console.log(date.getMonth()+1); getYear() 和 getFullYear()getYear()是不用了的，官方说使用getFullYear() 替换掉。getFullYear()从 Date 对象以四位数字返回年份。 JavaScript 12345var date = new Date();// 千年虫 2000年问题 千禧年问题 千年危机console.log(date.getYear());console.log(date.getFullYear()); 获取时分秒毫秒getHours()返回Date对象的小时 0-23getMinutes()返回Date对象的分钟 0-59getSeconds()返回Date对象的秒数 0-59getMilliseconds()返回 Date 对象的毫秒(0 ~ 999) getTime()getTime() 返回距1970年1月1日之间的毫秒数。很重要！！需要了解时间戳 timeStamp 计算机纪元时间：1970年1月0点0分0秒，过了多少毫秒 -&gt; 毫秒就是当前这个时间的时间戳 JavaScript 12345678910111213141516171819var start = new Date().getTime();for(var i = 0; i &lt; 1000; i++){ document.write(i + ' ');}var end = new Date().getTime();console.log(start,end);// 把时间戳放进Date()里面可以返回具体时间var dateTime = new Date(end);console.log(dateTime);// setTime 设置时间戳 -&gt; 设置成 2020年6月2日 var date = new Date(); //2020年6月2日的时间戳var dateTime2 = date.setTime(1591027200000);console.log(date); 设置时间JavaScript 1234567891011121314var date = new Date(2020,10,1,20,23,50);console.log(date);var date2 = new Date('2020-05-21 23:05:50');console.log(date2);// 上面的和下面没有任何区别 推荐使用上面的 // date.setFullYear(2020); // date.setMonth(5); // date.setDate(7); // date.setHours(20); // date.setMinutes(24); // date.setSeconds(23); // date.setMilliseconds(53); 计时器 -&gt; setIntervalsetInterval每隔特定的毫秒数时间执行一次内部函数，window下的方法。 JavaScript 1234567891011121314151617181920212223242526// 写法一 setInterval(function(){ console.log(1) },1000);// 写法二 setInterval(test,1000); //注意是没有括号的 function test(){ console.log(1); }// 写法三 setInterval('test2()',1000); // 注意这样就要写括号了 function test2(){ console.log(1); }// 写法二 var time = 1000; setInterval(function(){ },time); // 注意这是更改不了的 setInterval在运行的时候只会取一次值 time = 10; 返回值 -&gt; 唯一标识 每一个计时器系统都会分配它一个唯一标识。 1234567var timer = setInterval(function(){},1000);var timer1 = setInterval(function(){},1000);var timer2 = setInterval(function(){},1000);console.log(timer,timer1,timer2); 清除计时器 -&gt; clearInterval123456789var a = 0;var timer = setInterval(function(){ a++; console.log(a); if(a &gt; 5){ clearInterval(timer); }},1000); 延时器 -&gt; setTimeoutsetTimeout 延迟特定毫秒数执行一次函数 html 123456789101112131415161718192021222324 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;setTimeout案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;获取更多数据&lt;/button&gt; &lt;script&gt; var oBtn = document.getElementsByTagName('button')[0]; oBtn.onclick = function(){ this.innerHTML = \"加载中....\"; // 加下划线是这个函数私有的变量 var _self = this; setTimeout(function(){ console.log(this); console.log(_self); _self.innerHTML = '获取更多数据'; },2000); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; clearTimeoutclearTimeout 清除延时器 html 1234567891011121314151617181920212223 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;clearTimeout案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;5秒跳转百度&lt;/p&gt; &lt;button&gt;取消&lt;/button&gt; &lt;script&gt; var oPara = document.getElementsByTagName('p')[0], oBtn = document.getElementsByTagName('button')[0], t = setTimeout(function(){ location.href = 'http://www.baidu.com'; },5000); oBtn.onclick = function(){ clearTimeout(t); oPara.innerHTML = '已取消跳转'; } &lt;/script&gt;&lt;/body&gt; 作业1、原型上编程，写一个数字时钟2、原型上编程，写一个倒计时，如果位数不足两位的加个零 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Date","slug":"Date","permalink":"https://cokesprit.gitee.io/tags/Date/"}]},{"title":"DOM作业","date":"2020-09-17T08:01:50.000Z","path":"/posts/b02f6fe6/","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"createDoumentFragment","date":"2020-09-09T09:25:36.000Z","path":"/posts/caf761ec/","text":"createdocumentfragment()方法创建一虚拟的节点对象，节点对象包含所有属性和方法。createdocumentfragment又叫创建文档片段（碎片） html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;document.createdocumentfragment&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"list\"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 123456789101112131415var oList = document.getElementsByTagName('ul')[0];var oFrag = document.createDocumentFragment(); // 创建虚拟DOMfor(var i = 0 ; i &lt; 1000; i++){ var oLi = document.createElement('li'); oLi.innerHTML = i+'、这是我' + + '个项目'; oLi.className = \"list-item\"; oFrag.appendChild(oLi); //把创建的元素放进虚拟DOM里面}// 一次性渲染到oLlist里面大大的提升性能。oList.appendChild(oFrag); 总结：只要列表都建议用这种方式。DocumentFragment 是存在内存中的并不是存在DOM树上的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"data-*属性","date":"2020-09-09T08:01:24.000Z","path":"/posts/943046a0/","text":"data-*属性是HTML5中的新属性。赋予我们在所有HTML元素上嵌入自定义的data属性的能力。 可以通过dataset来管理这些自定义属性。注意：dataset PC端兼容性不是特别好IE9及以下不支持，手机端都是兼容的。自定义属性也可以使用setAttribute 和 getAttribute设置和获取 data-*属性html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;data-*属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p data-name=\"王小明\" data-age=\"21\"&gt; 我叫王小明 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var oP = document.getElementsByTagName('p')[0]; oP.dataset.name = \"张三\"; oP.dataset.age = \"21\";&lt;/script&gt; 运行结果: dataset练习通过自定义属性来判断哪些电影是付费电影，当单击的时候付费电影就弹出提示框，免费电影就直接跳转链接。 html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;data-*属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"javascript:;\" data-uri=\"egts\" data-sort=\"free\"&gt; 恶棍天使 &lt;/a&gt;&lt;/br&gt; &lt;a href=\"javascript:;\" data-uri=\"fczlm\" data-sort=\"pay\"&gt; 复仇者联盟 &lt;/a&gt;&lt;/br&gt; &lt;a href=\"javascript:;\" data-uri=\"zl\" data-sort=\"free\"&gt; 追龙 &lt;/a&gt;&lt;/br&gt; &lt;a href=\"javascript:;\" data-uri=\"plmxs\" data-sort=\"pay\"&gt; 普罗米修斯 &lt;/a&gt;&lt;/br&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 123456789101112131415var links = document.getElementsByTagName('a');for(var i = 0 ; i &lt; links.length; i++){ (function(j){ links[j].onclick = function(){ var sort = this.dataset.data-sort; var uri = this.dataset.data-uri; if(sort === \"free\"){ window.open('http:baidu.com/' + uri); }else{ alert(\"这是付费影片\"); } } })(i);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"元素属性设置获取","date":"2020-09-09T07:14:36.000Z","path":"/posts/949b6685/","text":"setAttribute()添加指定的属性，并为其赋值指定的值。如果这个指定的属性已存在，则仅设置/更改值。语法：setAttribute(‘属性名’,’属性值’); getAttribute()返回指定属性名的属性值。如果希望返回的是 Attr对象返回属性，就用getAttributeNode。语法：getAttribute(‘属性名’); JavaScript 123456// setAttribute 给元素增加属性和属性值var div = document.getElementsByTagName('div')[0];div.setAttribute('id','box');// getAttribute 获取属性值var attr = div.getAttribute('class'); 案例html 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;元素属性设置获取&lt;/title&gt; &lt;style&gt; .running{color:#3ae374;} .warning{color:orange;} .denger{color:red;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 系统正在运行... &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 12345678910111213141516171819var div = document.getElementsByTagName('div')[0]; function syetemStatus(statu){ div.setAttribute('class',statu); switch(statu){ case 'running': div.innerHTML = \"系统正在运行\"; break; case 'warning': div.innerHTML = \"系统运行有警告异常\"; break; case 'denger': div.innerHTML = \"系统存在危险\"; break; } } syetemStatus('warning'); js运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"节点操作","date":"2020-09-08T01:58:28.000Z","path":"/posts/f7e7dff7/","text":"常用的节点操作有创建节点、剪切节点/增加节点、插入节点、替换节点、删除节点 创建节点createElement、createTextNode、createComment 剪切/增加节点：appendChild() 插入节点：insertBefore() 替换节点：repelaceChild() 删除节点：removeChild()、remove() 创建节点createElement()、createTextNode()、createComment()，分别为创建元素节点、创建文本节点、创建注释节点 JavaScript 12345678// 创建元素节点var div = document.createElement('div');// 创建文本节点var text = document.createTextNode('Hello Word！！！');// 创建注释节点var comment = document.createComment('我是注释君'); 剪切/增加节点appendChild()方法向节点添加最后一个子节点。也可以使用appendChild()方法从一个元素向另一个元素中移动元素，实现剪切的功能。 增加节点JavaScript 12345// 获取divvar div = document.getElementsByTagName('div')[0];var p = document.createElement('p');p.innerHTML = \"JavaScript\";div.appendChild(p); // 把p元素添加到div里面去 剪切节点 html 123456789&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;剪切节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"\"&gt;hhh &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 12345// 获取元素avar a = document.getElementsByTagName('a')[0];var div = document.createElement('div');document.body.appendChild(div); div.appendChild(a); // 将a剪切到div里面 js运行结果： 插入节点insertBefore()方法在指定的已有节点之前插入新的子节点。也可以使用 insertBefore 方法插入/移动已有元素语法： parent.insertBefore(a,b); 将a元素插入到parent节点下的b元素前面。 html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;插入节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;我是p标签&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 123456var div = document.getElementsByTagName('div')[0];var p = document.getElementsByTagName('p')[0];var a = document.createElement('a');a.hrfe = '';a.innerHTML = '我是a标签';div.insertBefore(a,p); js运行结果： 替换节点replaceChild()方法将某个子节点替换为另外一个。语法：parent.replaceChild(newnode,oldnode); html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;替换节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &lt;h1&gt;我标题标签h1&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 1234var h1 = document.getElementsByTagName('h1')[0];var h2 = document.createElement('h2');h2.innerHTML = \"我是标题标签h2\";document.getElementById('box').replaceChild(h2,h1); js运行结果： 删除节点删除节点的方法有两个分别是：removeChild() 和 remove()。removeChild()方法从子节点列表中删除某个节点，成功删除返回被删除的节点，删除失败返回null。 remove()是真正的删除掉。ES5出来的。 二者的区别removeChild()删除的是DOM节点但是内存里面的空间并没有释放，而remove()是彻底的删除掉。 html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;删除节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;我是标题标签&lt;/h1&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;a href=\"\"&gt;我是超链接标签&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 123456var div = document.getElementsByTagName('div')[0];var p = document.getElementsByTagName('p')[0];console.log(div.removeChild(p)); var a = document.getElementsByTag('a')[0];console.log(a.remove()); js运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"DOM结构树","date":"2020-09-06T06:57:17.000Z","path":"/posts/25df9200/","text":"DOM结构树 DOM操作深入getElementById它是定义在Document.prototype上的，Element.prototype和HTMLElement.prototype并没有。 举例证明：html 1234567&lt;div id=\"box\" class=\"box\"&gt; 我是文本节点 &lt;!-- 我是注释君 --&gt; &lt;h1&gt;我是标题标签&lt;/h1&gt; &lt;a href=\"\"&gt;我是超链接&lt;/a&gt; &lt;p class=\"text\"&gt;我是段落标签&lt;/p&gt;&lt;/div&gt; JavaScript 12var div = document.getElementsByTagName('p')[0]; div.getElementById(); // 报错 因为HTMLElement.prototype上没有这个方法 js运行结果: getElementsByName它是定义在Doment.prototype上的。 getElementsByTagName….getElementsByTagNamegetElementsClassquerySelectorquerySelectorAll 这四个在Document.prototype 和 Element.prototype都有。 * 星号 -&gt; 通配符&nbsp;*&nbsp; DOM里面也有这个东西，&nbsp;*&nbsp;选出来所有标签。只能document.getElementsByTagName使用！！！ 举例证明：html 1234567&lt;div id=\"box\" class=\"box\"&gt; 我是文本节点 &lt;!-- 我是注释君 --&gt; &lt;h1&gt;我是标题标签&lt;/h1&gt; &lt;a href=\"\"&gt;我是超链接&lt;/a&gt; &lt;p class=\"text\"&gt;我是段落标签&lt;/p&gt;&lt;/div&gt; JavaScript 12var all = document.getElementsByTagName('*');console.log(all); js运行结果: 获取 body 和 headbody 和 head在HTMLDocument上定义有，所以可以直接通过 document.body 和 document.head来获取body和head标签。 JavaScript 12345678910var body = document.body;console.log(body);var head = document.head;console.log(head);// 那么有没有 title呢？有但不是返回元素,而是title里面的文本var title = document.title;console.log(title); js运行结果: documentElementDocument.prototype 提供了documentElement可以直接访问整个HTML文档。 作业 1.在原型上编程 要求 ：不能使用 children 和 childNodes 遍历任意一个父元素 找到它的子元素节点 有数字参数 -&gt; 某一个对应子元素 没有数字参数 -&gt; 子元素节点集合 提示：是写在那个原型上，怎么判断有无参数的时候返回的参数不同 2.在原型上编程 要求： 找出一个元素的第N层父级元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"封装childnodes方法","date":"2020-09-04T14:18:33.000Z","path":"/posts/db01237d/","text":"我们在获取子节点的时候虽然可以使用 childnodes 和 children,但是二者都有缺点,childnodes会把一些我们不需要的注释节点和文本节点等返回回来。childrenIE9以上版本才返回元素节点。所以我们需要封装一个只返回元素节点的方法。 简单封装JavaScript 12345678910111213function elemChildren(node){ var arr = [], children = node.childnodes; for(var i = 0; i &lt; children.length; i++){ var childItem = children[i] if(childItem.nodeType === 1 ){ arr.push(childItem) } } return arr;} 使用类数组的方式进行封装JavaScript 12345678910111213141516171819function elemChildren(node){ var temp = { 'length':0, 'push':Array.prototype.push, 'splice':Array.prototype.splice }, len = node.childNodes.length; for(var i = 0; i &lt; len; i++){ var childItem = node.childNodes[i]; if(childItem.nodeType === 1){ temp[temp['length']] = childItem; temp['length']++; } } return temp;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"节点属性和方法","date":"2020-09-04T14:05:48.000Z","path":"/posts/e02e7815/","text":"nodeNamenodeVauenodeTypeattributesgetAttributeNode这几个属性除了 nodeType 是经常用其他都不怎么用。 html 1234567&lt;div id=\"box\" class=\"box\" style=\"background-color: green;\"&gt; 我是文本节点 &lt;!-- 我是注释君 --&gt; &lt;h1&gt;我是标题标签&lt;/h1&gt; &lt;a href=\"\"&gt;我是超链接&lt;/a&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/div&gt; nodeNamenodeName 属性可依据节点的类型返回其名称。如果节点是一个元素节点 , nodeName 属性将返回标签名。如果节点是一个属性节点， nodeName 属性将返回属性名。其他节点类型, nodeName 属性将返根据不同的节点类型返回不同的节点名称。nodeName -&gt; 只读JavaScript 1234var div = document.getElementsByTagName('div')[0]; console.log(div.nodeName); console.log(document.nodeName); console.log(div.nodeName.toLowerCase()); // 转小写 js运行结果： nodeValuenodeValue属性根据节点的类型设置或返回节点的值。nodeValue属性可读可写，属性、注释、文本节点可用。JavaScript 1234567891011121314var div = document.getElementsByTagName('div')[0]; // 文本节点 也有nodeValue console.log(div.firstChild.nodeValue); // 注释节点 也有nodeValue console.log(div.childNodes[1].nodeValue); // 元素节点 没有nodeValue console.log(div.childNodes[3].nodeValue); // null // 属性节点也有 nodeValue console.log(div.getAttributeNode('id').nodeValue); console.log(div.firstChild.nodeValue = \"我是假的文本节点\"); js运行结果： nodeTypenodeType返回节点类型。无比重要！！！ 只可读不可修改。 节点名称 节点类型 元素节点 1 属性节点 2 文本节点 3 注释节点 8 document 9 DocumentFragment 11 JavaScript 123456789101112var div = document.getElementsByTagName('div')[0]; // 结果返回1 -&gt; 元素节点 console.log(div.nodeType); // 结果返回2 -&gt; 属性节点 console.log(div.getAttributeNode('id').nodeType); // 结果返回3 -&gt; 文本节点 console.log(div.firstChild.nodeType); // 结果返回8 -&gt; 注释节点 console.log(div.childNodes[1].nodeType); js运行结果： attributes getAttributeNodeattributes方法获取一个元素的属性集合getAttributeNod方法获取元素属性这两个了解即可。 hasChildNodeshasChildNodes 判断节点下有没有子节点,返回true或false。 JavaScript 123var box = document.getElementsByClassName('box')[0];// 注意换行也是属于文本节点！！！console.log(box.hasChildNodes()); js运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"document对象、获取元素、节点、遍历树","date":"2020-09-02T13:52:31.000Z","path":"/posts/edf1905e/","text":"documentdocument 代表的是整个HTML文档,HTML是一个根标签，而docment是整个文档的最上层，HTML是document的下一级。 获取元素getElementById通过元素的id来选择元素，只有getElementById是选择一个元素，其他都是选择一组的。 开发习惯和规范问题:id在项目当中是不可以顺便乱用的，在大公司里面id一般是不作为样式去定义的，一般在一些大公司里面这个id称为 钩子，真正的id的用处是拿来对接后端的，这个id在模块化开发当中一般来是一个模块一个id，能不用id尽量不用id,在大公司里面id一般不是你定的。 getElementsByClassName通过元素class来选择元素，返回的是一个数组。在IE8及以下的是没有这个方法，所以说DOM和BOM队兼容性要求比较高。 getElementsByName通过元素的name来选择元素，返回一个数组，支持到ie4这个极不常用。 querySelector querySeclectorAll这两个是HTML5这个版本新引入的WEB API，但是它们两个很早之前就有了，它们两个比getElementsByClassName还要早，兼容IE7,IE6及以下不兼容，querySelector 和 querySeclectorAll 它们两个的写法和CSS选择器是一样的。 querySelector 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;querySelector&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;div&gt;456&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); console.log(div); var div2 = document.querySelector('div')[1]; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js运行结果： 1 总结:如果类和标签有多个的话，querySelector只会选择第一个，它不能选择一组。 querySelectorAll 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;querySelectorAll&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;123&lt;/div&gt; &lt;div class=\"box\"&gt;456&lt;/div&gt; &lt;div id=\"box\"&gt;789&lt;/div&gt; &lt;script&gt; var div1 = document.querySelectorAll('.box'); console.log(div1); var div2 = document.querySelectorAll('#box'); console.log(div2); var div3 = document.querySelectorAll('.box')[1]; console.log(div3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js运行结结果： 总结：querySelectorAll 使用无论类、id、标签，返回来的都是一组。 querySelector和querySelectorAll的缺点1.性能要比get慢得多 -&gt; 公司用的少2.不实时,相当于存了一个缓存在那，稍微有点有点更改对它都是无效的。这才是它们最致命的缺点。例子 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;querySelector和querySelectorAll的缺点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;123&lt;/div&gt; &lt;div class=\"box\"&gt;456&lt;/div&gt; &lt;div class=\"box\"&gt;789&lt;/div&gt; &lt;script&gt; var divs = document.querySelectorAll('.box'); divs[0].remove(); console.log(divs); // 节点并没有被删除！！！ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 遍历节点树节点不是元素，元素是节点的一部分。节点包含元素 -&gt; 元素节点 = DOM元素 parentNode父节点，每个子元素只有一个父节点 html 1234567&lt;ul&gt; &lt;li&gt; &lt;h2&gt;我是标题标签&lt;/h2&gt; &lt;a href=\"\"&gt;我是超链接标签&lt;/a&gt; &lt;p&gt;是段落标签&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; JavaScript 12var a = document.getElementsByTagName('a')[0]; console.log(a.parentNode);// a的父节点是li js运行结果： childNodeschildNodes子节点集合常用的节点有：1、元素节点 = 12、属性节点 = 23、文本节点(#text) = 3 换行也算是文本节点！！！4、注释节点(#comment) = 85、document = 96、DocumentFragment = 11后面的数字表示节点号 html 12345678&lt;ul&gt; &lt;li&gt;123 &lt;!-- 我是注释 --&gt; &lt;a href=\"\"&gt;我是超链接标签&lt;/a&gt; &lt;p&gt;是段落标签&lt;/p&gt; &lt;h1&gt;我是标题标签&lt;/h1&gt; &lt;/li&gt;&lt;/ul&gt; JavaScript 123var li = document.getElementsByTagName('li')[0];console.log(li.childNodes.length); // 9console.log(li.childNodes); js运行结果: firstChild lastChild第一个子节点，最后一个子节点 JavaScript 123var li = document.getElementsByTagName('li')[0]; console.log(li.firstChild); //\"123\" console.log(li.lastChild); // #text js运行结果: nextSibling previousSibling下一个兄弟节点,上一个兄弟节点 JavaScript var p = document.getElementsByTagName('p')[0]; console.log(p.previousSibling) console.log(p.nextSibling); console.log(p.nextSibling.nextSibling); js运行结果: 补充遍历节点树补充： 在公司里面只使用parentNode和childNodes,其他都是不用的,虽然其他不用但是一定要认识。 遍历元素节点树 parentElement -&gt; 父元素 children -&gt; 子元素 firstElementChild lastElementChild -&gt; 第一个子元素 最后一个子元素 nextElementSibling previousElementSibling -&gt; 下一个兄弟元素 上一个兄弟元素 JavaScript // parentElement var p = document.getElementsByTagName('p')[0]; console.log(p.parentElement); var html = document.getElementsByTagName('html')[0]; console.log(html.parentElement); // 总结：html标签有父节点 -&gt; #document ，但是但是但是没有父元素 // children var li = document.getElementsByTagName('li')[0]; console.log(li.children); //[a, p, h1] // 笔试 // childElementCount = children.length 这两个是一样的 不过前者没人用 console.log(li.childElementCount,li.children.length); // 3 3 // firstElementChild lastElementChild console.log(li.firstElementChild,li.lastElementChild); // nextElementSibling previousElementSibling console.log(p.previousElementSibling,p.nextElementSibling); js运行结果: 补充遍历节点树补充：parentElement IE9及以下不支持children IE7及以下不支持childElementCount = children.length IE9及以下不支持firstElementChild lastElementChild IE9及以下不支持nextElementSibling previousElementSibling IE9及以下不支持在公司里面除了children有时候用之外,其他都没有人用,虽然不用但是不得不认识!!! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"DOM介绍","date":"2020-09-02T13:15:10.000Z","path":"/posts/f75e92e9/","text":"DOM : Document Object Model 文档对象模型。DOM是一个对象 -&gt; 又叫宿主对象 -&gt; 浏览器提供的。 JavaScript的3种对象本地对象本地对象 Native Object ：Object、function、Array、String、Number、Boolean、Error、EvalError、SyntaxError、 SyntaxError、RangeError、ReferenceError、TypeError、URIError Date、RegExp 内置对象内置对象 Built-in ObjectGlobal 、 MathGlobal是全局内置对象的总称但是它在ECMA是不存在的是虚拟的，ECMA -&gt; isNaN() parseInt() Number decodeURI EencodeURI Infinity NaN undefined 等等这些属性和方法都是属于Global。补充:本地对象和内置对象都是ECMAScript的内置对象。 宿主对象宿主对象 Host Object执行JS脚本的环境提供的对象，所以宿主对象又称为浏览器对象，使用浏览器对象会涉及到兼容性问题。 浏览器对象：window(BOM) 和 document(DOM),DOM是有W3C规范的，document是存在window下的。DOM的作用：通过浏览器提供的这一套方法表示或操作HTML/XML。注意DOM是操作不了CSS的。它只是操作style这属性并没有直接操作样式表。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOM","slug":"DOM","permalink":"https://cokesprit.gitee.io/tags/DOM/"}]},{"title":"hexo 博客文章发布部署","date":"2020-09-02T10:56:29.786Z","path":"/posts/c3259ce2/","text":"创建新帖子1$ hexo new \"My New Post\" 运行服务器1$ hexo server 生成静态文件1$ hexo generate 部署到远程站点$ hexo deploy 作者：可乐精链接：CokeSprit著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"hexo","slug":"hexo","permalink":"https://cokesprit.gitee.io/tags/hexo/"}]},{"title":"ES5严格模式","date":"2020-08-28T09:08:36.000Z","path":"/posts/654e1570/","text":"ES5的严格模式,是ECMAScript要求对严格模式要强调，因为他们希望我们能够严格遵守ES5的语法和各种方法使用的规定，为ES6做铺垫。 ECMAScript发展历程97年 1.098年 2.099年 3.0 -&gt; JS通行标准这三年发展非常快，这ES3.0几乎奠定了ES5的大部分内容,其实ES5几乎全是ES3.0的内容,ES3.0到现在为止都统治着JavaScript，实际上ES5.0并没有对ES3.0进行十分多的更新。4.0 去了哪呢? 07年 4.0 -&gt; 太过激进 -&gt; 浏览器厂商不接受雅虎和微软都非常反对。 08年 4.0 中止（中止并不等于废除）：把一部分容易改善的部分放到了ES3.0,发布了3.1一些比较激进的部分给了一个版本代号 Harmony -&gt; 开了这个会后 ES3.1 -&gt; 更名为ECMAScript5.0，但是更改了之后ECMAScript5还是没有发布。 09年 5.0发布 Harmony -&gt; 分成连部分：1.一部分是激进当中不那么激进的部分 -&gt; 更名为 JS.NEXT2.激进部分 -&gt; JS.next.next 11年 5.1 ISO国际标准 -&gt; 而且这个5.1几乎还是基于3.0的标准 13年 ES6 = js.next js.next.next 放到es7里面 13年 ES6 草案发布 15年 ES6 正式发布 -&gt; ES6又名ECMAScrit2015 ES5的两个运行模式：正常模式 严格模式IE9及以下不支持严格模式 为什么要有严格模式？这是一个历史遗留问题,3.0太早了99年的,语法的严谨性和合理性有不足的地方,语法怪异安全性不足。 如何使用严格模式“use strict” 如果是脚本启动就是写在最上面的一行 还有一种就是写在函数里面,这很多大厂都这样写 123function test(){ 'use strict'} 严格模式有那些影响在严格模式下有一些属性是不能使用的例如：caller、callee、with、arguments下的大部分属性都是不可以用的,注意arguments是可以用的。 严格模式下this指向非严格模式下函数内部的this指向window 严格模式下如果函数没实例化this指向undefined,new 实例化之后this就指向该构造函数 123456// 没实例化之前严格模式下this指向\"use strict\"function test(){ console.log(this);}test(); 运行结果： 123456// 实例化之后\"use strict\"function test(){ console.log(this);}var test1 = new test(); 运行结果： 严格模式下call非严格模式下call()里面填的原始值的话它会经过包装类成为对象 12345// \"use strict\"function test(){ concole.log(this); // }test.call(1); 运行结果： 函数的参数不能重复命名非严格 -&gt; 不报错严格模式 -&gt; 报错 -&gt; 严格模式下函数参数不能重复命名 12345\"use strict\"function test(a,a){ console.log(a);}console.log(1,2); 运行结果： 笔试题严格模式 -&gt; 对象命名不允许重复但 -&gt; 不报错 123456\"use strict\"var obj = { a: 1, a: 2}console.log(a) 运行结果： 严格模式下eval(); 作用域被改变 12345// 这样在严格模式下 -&gt; 不报错eval('var a = 1; console.log(a)');// 但如果下面还打印a就报错console.log(a); 运行结果： 在严格模式下eval是有自己独立的作用域的,已经不再是全局的作用域了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js错误信息篇","slug":"js错误信息篇","permalink":"https://cokesprit.gitee.io/tags/js%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AF%87/"}]},{"title":"try...catch...","date":"2020-08-28T08:18:55.000Z","path":"/posts/a86aeb16/","text":"当系统自动为我们抛出错误的时候程序就不会继续执行，为了解决这个问题我们在可能会报错的地方使用手动抛出错误的方法 -&gt; try…catch…finally…throw,后面两个可以不写但是try…catch是一定要的。 try: 里面没有错误的时候它是不走catchcatch: 第一大要务就是捕获try里面的错误finally: 不管catch里没有错误都执行throw: 可以通过throw 扔出自定义错误 系统自动为我们抛出错误123console.log('正常执行1');console.log(a);console.log('正常执行2'); 运行结果： 手动抛出错误try…catch…finally…throw 1234567891011try{ console.log('正常执行1'); console.log(a); console.log('正常执行2');}catch(e){ console.log(e.name); // 错误类型 console.log(e.message); //错误的具体信息}finally{ console.log('正常执行3');}console.log('正常执行4'); 运行结果： 123456789101112131415161718192021var jsonStr = '';try{ if(jsonStr == ''){ // 抛出错误 throw 'JSON字符串为空'; } // 上面抛出错误了所以下面这里并没有执行 console.log(\"我要执行了!!!\"); var json = JSON.parse(jsonStr); console.log(json);}catch(e){ console.log(e); // 换方案执行 var errorTip = { name:'数据传输失败', errorCode:'10010' } console.log(errorTip);} 运行结果： 补充try … catch 一般用在比较大型的web程序插件里面比较多，一般开发的时候用的比较少。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js错误信息篇","slug":"js错误信息篇","permalink":"https://cokesprit.gitee.io/tags/js%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AF%87/"}]},{"title":"JS错误类型","date":"2020-08-28T01:44:10.000Z","path":"/posts/e24d4eb8/","text":"JavaScript有六种错误类型，每一种类型都对应着一种构造函数,这些构造函数都可以通过实例化去定义错误类型。除此之外还有一个总的错误类型 Error。下面分别介绍这六种错误类型。 SyntaxErrorSyntaxError -&gt; 语法错误，有以下几种情况： 变量名不规范1var 1ab = 1; 运行结果： 关键字赋值1function = 1; 运行结果： 基本语法错误1var a = 1: 运行结果： ReferenceErrorReferenceError -&gt; 引用错误 -&gt; 以下都是报引用错误 变量或者函数未声明12test();console.log(a); 运行结果： 给无法被赋值的对象赋值的时候1var a = 1 = 2; 运行结果： RangeErrorRangeError -&gt; 范围错误 -&gt; 以下都是报引范围错误 数组长度赋值为负数123var arr = [1,2,3];arr.length = -1;console.log(arr); 运行结果： 对象方法参数超出可行范围123var num = new Number(66.66);// toFixed 保留小数点几位console.log(num.toFixed(-1)); // 如果为 -1就会报错 运行结果： TypeErrorTypeError -&gt; 类型错误 -&gt; 以下都是报引类型错误 调用不存在的方法1234// 如果写 test(); -&gt; ReferenceError -&gt; 引用错误 // 但 如果写 123(); 报类型错误123(); 运行结果： 123var obj = {};obj.say(); // obj.say; // 这样就不会有错误 运行结果： 没有括号的时候不会报错,证明如果没有这个括号的时候JavaScript会认为这是一个属性只是没有赋值。加了括号以后属性执行了,但是属性不能像函数那样执行,所以报 TypeError -&gt; 类型错误。 实例化原始值1234// new 后面必须是一个构造器var a = new 'String';// var b = new 123; //还是会报类型错误 运行结果： URIErrorURIError -&gt; 编码错误URI介绍：URI：UNIFORM RESOURCE IDENTIFIER 统一的资源标识符URL：UNIFORM RESOURCE LOCATOR 统一资源定位符URN：UNIFORM RESOURCE NAME 统一资源名称 URL和URN是URI的子集 URL：有传输协议、有域名、或者有资源空间例如：http://www.baidu.com/new#todayftp://www.baidu.com/ftp#developer URN：www.baidu.com/ftp#developer -&gt; 唯一的IDhrfe=”tel:13900000”href=”mailto:2665281140@qq.com“ 1234567891011var myUrl = \"http://www.baidu.cin?name=可乐\"; // encodeURI 把URI里面的中文转化为中文字符编码var newUrl = encodeURI(myUrl);console.log(newUrl) // decodeURI将中文编码转化成中文var newNewUrl = decodeURI(newUrl); console.log(newNewUrl); // 如果decodeURI 里面的中文编码乱填的haul就会报错var str = decodeURI('%fdsd'); 运行结果： EvalErrorEvalError -&gt; 全局错误 eval函数执行错误现在呢，这个已经不那么容易报错了。eval();最大的功能是可以在括号写JavaScript程序然后执行还有就是把json对象转化成课循环的对象。不过现在已经很少使用了，es6已经完全摒弃了。 12eval('var a = 1;console.log(a)');console.log(a); 运行结果： 把json对象转化成可循环的对象 123456789101112131415161718var jsonDate = '['+ '{'+ '\"name\": \"abc\"'+ '},'+ '{'+ '\"name\": \"bc\"'+ '},'+ '{'+ '\"name\": \"c\"'+ '},'+']';var data = eval('(' + jsonDate +')');console.log(data);for(var i in data){ var item = data[i]; console.log(item.name);} 运行结果： 为什么不推荐使用 eval?1.实际上es3就不建议是用了es5.0也不建议使用，es6已经完全摒弃了2.语法规范不好3.不好调试4.性能问题5.些许的安全性问题6.可读性差 总结JavaScript的错误类型一共有六种：SyntaxError -&gt; 语法错误ReferenceError -&gt; 引用错误RangeError -&gt; 范围错误TypeError -&gt; 类型错误URIError - 编码错误（比较少见）EvalError -&gt; 编码错误 （很少见） 这六种错误类型都可以人为的抛出通过 new来： 1234567891011121314151617181920var Syerror = new SyntaxError('语法错误');console.log(Syerror);var Reerror = new SyntaxError('引用错误');console.log(Reerror);var Raerror = new SyntaxError('范围错误');console.log(Raerror);var Tyerror = new SyntaxError('类型错误');console.log(Tyerror);var URerror = new SyntaxError('编码错误');console.log(URerror);var Everror = new SyntaxError('编码错误');console.log(Everror);var srror = new Error(\"总的Error\"); // 总的Errorconsole.log(srror); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js错误信息篇","slug":"js错误信息篇","permalink":"https://cokesprit.gitee.io/tags/js%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AF%87/"}]},{"title":"字符串去重","date":"2020-08-26T11:42:53.000Z","path":"/posts/dc5c6a5/","text":"字符串去重思路思路和数组的一样的,不过字符串去重相对来说简单一点; 12345678910111213141516171819var str = \"aaa1111222333ddewdd6\";// 方法挂载在String.prototype上String.prototype.unique = function(){ var temp = {}, newStr = ''; for(var i = 0; i &lt; this.length; i ++){ if(!temp.hasOwnProperty(this[i])){ temp[this[i]] = this[i]; //字符串拼接对象也可以 newStr += this[i]; } } return newStr;}console.log(str.unique()); 运行结果： 注意：字符串去重的时候方法挂载在String.prototype上。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"https://cokesprit.gitee.io/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"数组去重","date":"2020-08-26T11:12:22.000Z","path":"/posts/908d091d/","text":"123456789101112131415161718192021222324252627282930// 在JavaScript中属性是字符串只是它可以把字符串变成变量类型 // obj = { // \"0\": 1, // \"1\": 2, // \"2\": 3, // \"3\": 4, // \"4\": 5 // }var arr = [0,0,1,1,2,2,3,3,4,'d'];Array.prototype.unique = function(){ var temp = {}, newArr = []; for(var i = 0; i &lt; this.length; i++){ // 如果不存在则为false,然后取反就为true if(!temp.hasOwnProperty(this[i])){ // 把它添加到对象里面去 temp[this[i]] = this[i]; // 添加到一个新的数组 newArr.push(this[i]); } } // 返回到外界 return newArr;}console.log(arr.unique()); 运行结果: 实现思路：使用for和if还有对象的hasOwnProperty来循环判断添加到个空对象里面，同时添加到一个新的数组里面。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"类数组","date":"2020-08-26T04:01:27.000Z","path":"/posts/5b0dde5/","text":"类数组并不是真正意义上的数组它是类似于数组的对象！！！类数组一定要有以下这几种形式：第一、一定要有数组形式下标对应的值;第二、一定要有length属性;第三、要挂载有数组原型上的方法例如:Array.prototype.push 或者 Array.prototype.splice; 注意：类数组的原型是object真正的数组原型是Array接下来举例子说明： arguments类数组arguments 最典型的的类数组,我们来打印一下它 1234function test(){ console.log(arguments);}test(1,2,3,4,5,6); 运行结果： 写一个类数组按照上面的几种形式写一个完整的类数组 12345678910111213141516171819var obj = { '0':'1', '1':'2', '2':'3', '3':'4', '4':'5', '5':'6', 'length':6, // 也可以将它们挂载到对象的原型上 'push': Array.prototype.push, 'splice': Array.prototype.splice}// 也可以挂载到原型上去// Object.prototype.push = Array.prototype.push;// Object.prototype.splice = Array.prototype.splice;obj.push(\"7\");console.log(obj); 运行结果： 思考push方法是怎么做到的？ 为什么它能在类数组里面起作用呢？ 12345678// push原理在类数组的原理Array.prototype.push = function(elem){ // 真正的写法 谁用this就指向谁 this[this.length] = elem; this.length ++;} 阿里题目下面的打印结果是怎么样的? 1234567891011var obj = { '2':3, '3':4, 'length':2, 'splice': Array.prototype.splice, 'push': Array.prototype.push}obj.push(1);obj.push(2);console.log(obj); 运行结果： 结果为两个空，一个 1 ，一个 2,length长度变成了 4。它是怎么来的呢？ 123456789101112131415// 根据push的原理一步一步的剖析 Array.prototype.push = function(){ this[this.length] = elem; this.length ++; // 最开始length长度为 2 // 第一次push // obj[2] = 1; // obj.length ++; //obj.length变成 3 // 第二次push // obj[3] = 2; // obj.length ++; // obj.length 变成4 } 执行完两次length变成了4，之前的 0 和 1项并没有发生改变而3 和 4 被 1 和 2替换掉了。 补充讲一讲为什么会打印 empty？这是数组的一个特性，可以有空的项,类数组也同样具备这样的特性。 123// 之前讲过的稀松数组var arr = [,,5,6];console.log(arr); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组深入篇","date":"2020-08-24T12:27:16.000Z","path":"/posts/3061e2e2/","text":"数组的深入篇有五个方法分别是concat、slice、toString、join和split。这五个数组方法都不会修改原数组，下面逐个进行讲解。 concat数组concat方法拼接数组,返回拼接后的数组。 1234var arr = ['c','d'];var arr1 = ['a','b'];var arr2 = arr1.concat(arr);console.log(arr2); 运行结果: slice数组slice方法截取数组,并返回截取的部分语法：slice(起始下标包含，结束下标不包含)如果不写参数那就是返回整个数组(数组克隆)如果只写一个参数,就从这个位置截取到最后 1234567891011121314151617181920var arr = ['a','b','c','d','e'];var arr0 = arr.slice();console.log(arr0)console.log(\"\"); var arr1 = arr.slice(1);console.log(arr1)console.log(\"\"); var arr2 = arr.slice(1,4); // b c dconsole.log(arr2)console.log(\"\"); var arr3 = arr.slice(-3,4); // c dconsole.log(arr3)console.log(\"\"); var arr4 = arr.slice(1,-1); // b c dconsole.log(arr4); 运行结果: toString数组toString方法将数组转化成字符串每个元素之间用逗号隔开 1234var arr = ['a','b','c','d'];var arr1 = [1,2,3,4];console.log(arr.toString());console.log(arr1.toString()); 运行结果: join和splitjoin 和 split 是一组!!!! join把数组中的所有元素放入一个字符串。有一个参数该参数通过指定分隔符进行分隔。如果join里面不填写参数那么它和toString方法是一样的。 1234567891011121314var arr = ['a','b','c','d'];// 不填写参数时console.log(\"join不填写参数时：\");var str1 = arr.join();var str2 = arr.toString();console.log(str1+\" \"+str2);console.log(\" \");// 填写参数时console.log(\"join填写参数时：\");var str3 = arr.join(\"-\")console.log(str3); 运行结果: splitsplit(‘分隔符’,’截取位数’)将字符串按照分隔符转换成数组,二个参数为截取的位数可以不写。如果把空字符串 (“”) 用作 参数那么每个字符之间都会被分割。join 和 split 是一组!!! 123456789101112131415161718192021222324var arr = ['a','b','c','d'];// 使用join 变成字符串var arr1 = arr.join();console.log(arr1); // a,b,c,dconsole.log(\" \");// 传入\"\" 的时候var arr2 = arr1.split(\"\"); // [\"a\", \",\", \"b\", \",\", \"c\", \",\", \"d\"]console.log(arr2);console.log(\" \");var arr3 = arr1.split(\",\"); // [\"a\", \"b\", \"c\", \"d\"]console.log(arr3);console.log(\" \");// 传入+ 的时候var arr4 = arr1.split(\"+\");console.log(arr4); // [\"a,b,c,d\"]console.log(\" \");// 有第二个参数时var arr5 = arr1.split(\",\",3);console.log(arr5); // [\"a\", \"b\", \"c\"] 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组排序sort方法","date":"2020-08-23T13:25:47.000Z","path":"/posts/cc10395e/","text":"sort方法按照ASCII来对数组进行排序,返回排序以后的数组,默认按升序排序。当数值有参数传进去的时候只接受函数且这个函数要满足以下两个规则:1.函数里面必须包含两个参数a，b2.必须要有返回值：负值，a就排在前面正值，b就排在前面0 ，保持不动 这两个规则是重中之重,只要掌握了这两个规则啥都不是问题 例子一1234567891011var arr = [27,49,5,7,2];arr.sort(function(a,b){ if(a &gt; b){ return 1; }else{ return -1; } // 简写 // return a - b;});console.log(arr); 例子二降序1234567891011var arr = [27,49,5,7,2,100];arr.sort(function(a,b){ if(a &lt; b ){ return 1; }else{ return -1; } // 简写 // return b - a;});console.log(arr); 运行结果： 笔试 / 面试随机排序1234567891011121314var arr = [1,2,3,4,5,6];arr.sort(function(a,b){ var rand = Math.random(); if(rand &gt; 0.5){ return 1; }else{ return -1; } // 简写 return Math.random() - 0.5;});console.log(arr); 运行结果： 对象排序 根据年龄12345678910111213141516171819202122232425262728293031var arr = [ { name:'张三', age: 18 }, { name:'李四', age: 12 }, { name:'王五', age: 8 }, { name:'赵六', age: 28 },];arr.sort(function(a,b){ if(a.age &gt; b.age){ return 1; }else{ return -1; } // 简写 // return a.age - b.age;});console.log(arr); 运行结果： 字符串排序对比字符串的长度 12345var arr = ['12346','5','1613','54'];arr.sort(function(a,b){ return a.length - b.length;});console.log(arr); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的splice方法","date":"2020-08-22T10:03:23.000Z","path":"/posts/32269d8b/","text":"splice方法可以实现数组的插入删除修改的功能,有三个参数。返回值是以一个数组的形式返回删除的数组。splice(开始项的下标(包含),剪切长度,剪切长度以后最后以为开始添加数据); 剪切长度可以是0和负数。 示例一12345var arr = [1, 2, 3, 4];// 在下标为 1 的地方 删除2位 插入3位arr.splice(1,2,'a','b','c')console.log(arr); 运行结果： 示例二123456// 在 c 和 e 之间添加 dvar arr = ['a', 'b', 'c', 'e'];// 在下标为3 的地方 删除0位 插入一位arr.splice(3, 0, 'd');console.log(arr); 运行结果: 笔试经常考12345var arr = ['a', 'b', 'c', 'e'];arr.splice(-1, 0, 'd'); // -1 即e 所在的位置console.log(arr); // 只要往后数就是 -1 开始 &lt;--- // 只要往前开始就是从 0 开始 ---&gt; 运行结果: splice是如何找到相应的下标的splice 当下标为负数的时候是如何找到相应的下标的它的原理是什么? 12345678910111213141516171819// 传入数组和下标function splice(arr,index){ // 常规写法 // 如果index下标大于或等于0 // if(index &gt;= 0){ // index += 0; // }else{ // // 否则就 index = index + arr.length // index += arr.length; // } // 三目运算 return index += index &gt;=0 ? 0 : arr.length;} var arr = ['a', 'b', 'c', 'e']; var str = splice(arr,-1); console.log(str); // 3 console.log(arr[str]); // e 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的reverse方法","date":"2020-08-22T09:52:20.000Z","path":"/posts/fd9290b5/","text":"reverse 数组倒序排列,就是一个倒序的功能而已 123var arr = ['a', 'b', 'c', 'd'];arr.reverse();console.log(arr); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的pop和shift方法","date":"2020-08-22T09:42:31.000Z","path":"/posts/a6d7cc58/","text":"pop 删除数组的最后一位，并把它返会回来shift 删除数组的第一位，并把它返回回来 1234567891011// popvar arr1 = [1,2,3,4];var str1 = arr1.pop(); // 注意pop是没有参数的!!! 它执行一次删除一个console.log(str1,arr1);// shiftvar arr2 = [5,6,7,8]; // 注意shift也是没有参数的!!! 它执行一次删除一个var str2 = arr2.shift();console.log(str2,arr2); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的push和unshift方法","date":"2020-08-22T09:15:29.000Z","path":"/posts/f5194d63/","text":"push 尾部添加，返回值为执行了方法以后数组的长度unshift 头部添加，返回值为执行了方法以后数组的长度 push方法的实现123456789101112var arr = [1,2,3]; // 尾部添加：获取实参列表和现最后坐标Array.prototype.myPush = function(){ for(var i = 0; i &lt; arguments.length; i++){ this[this.length] = arguments[i]; } return this.length; // 返回添加后的数组长度}console.log(arr.myPush(\"a\",\"b\",\"c\"));console.log(arr); 运行结果: unshift方法的实现第一种123456789101112Array.prototype.myUnshfit = function(){ var pos = 0; for(var i = 0; i &lt; arguments.length;i++){ this.splice(pos,0,arguments[i]); pos++; } return this.length;}var arr = ['d','e','f'];var str =arr.myUnshfit('a','b','c');console.log(arr,str); 运行结果: 第二种使用数组concat方法和使用Array.prototype.slice.call 将argument类数组转化成数组 123456789Array.prototype.myUnshift = function(){ // 将类数组转化成数组 Arr = Array.prototype.slice.call(arguments) var newArr = Arr.concat(this); return newArr;}var arr = ['c','d','e'];var newArr = arr.myUnshift('a','b');console.log(newArr); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的声明和数组的原理","date":"2020-08-22T08:32:04.000Z","path":"/posts/75ee3634/","text":"三种声明数组的方式12345678// 推荐var arr1 = []; // 字面量// 不推荐var arr2 = new Array(); // 通过系统内置的Array 构造函数声明// 不使用var arr3 = Array(); // 可以省略new 数组的原型这三种声明数组的原型是？ 123456789var arr1 = []; var arr2 = new Array();var arr3 = Array(); console.log(arr1.__proto__);console.log(arr2.__proto__);console.log(arr3.__proto__); 运行结果: 总结：所有数组都继承与Array.prototype 数组到底是什么12345678910111213141516171819202122232425// 模仿数组var arr = [1, 2, 3, 4, 5]; // 0 1 2 3 4 // 数组的下标是从零开始的 // index 数组元素的下标(索引值)// 对象var obj = { 0: 1, 1: 2, 2: 3, 3: 4, 4: 5}console.log(arr[2]);console.log(obj[2]);// 结果是一样的，实际上数组的底层机制在JavaScript就是继承对象而来的 // var obj1 = { // name:'a' // } // 数组就是利用了对象的这种机制,而形成JavaScript中的数组,以及对数组元素的访问 // obj1.name -&gt; obj1['name'] 系统机制 运行结果: 总结： 在JavaScript中数组就是对象的另一种形式，虽然写法不同但是它们的底层机制和访问机制是一样的。 稀松数组1234var arr = [,1,2,,3,4,]; // 稀松数组console.log(arr.length);// var arr1 = new Array(,1,2,,3,4); // 这种是不行的 因为这传的是参数不能为空 运行结果: 总结： 数组不一定每一位都有值但是如果最后一位没有值就等于没有最后一位 注意12345678910111213141516var arr = [1,2,3,4,5,6];console.log(arr[6]); // undefined// 为什么打印undefined？// 因为var obj = { 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6}// 数组和对象的底层机制是一样的。没有那个相对于的属性名所以undefined console.log(obj[10]); // undefined 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"看似牛掰的对象拷贝","date":"2020-08-21T01:30:01.000Z","path":"/posts/c8cf727d/","text":"对象拷贝分为浅拷贝和深拷贝也叫做克隆,拷贝对象的时候总会设计到引用值的问题，声明了一个新对象赋值了原来已有的对象,这个时候它们是指向同一个地址的。如果新对象变老对象也会变,老对象变新对象也会跟着变，这就造成了拷贝对象的一个困惑不仅仅是对象数组也是一样的。例如下面的例子: 12345678910var person1 = { name:'张三', age:18}var person2 = person1;person2.name = '李四';person2.sex = 'male';console.log(person1,person2); 运行结果: 知道问题之后我们接下来就来解决它 浅拷贝对象的拷贝其实就是对引用值的拷贝/复制/克隆,最好的方法就是循环的添加到另一对象。 12345678910111213141516171819202122232425262728293031 Object.prototype.num = 1; var person1 = { name:'张三', age: 18, sex: 'male', son:{ fitst:'Jenney', second:'Lucy', third:'Jone' } } // 这就是浅拷贝的方法使用 for in 来实现function clone(origin,target){ var target = target || {} for(var key in origin){ //hasOwsProperty 如果对象具有指定名称的属性,则返回true，否则false。 if(origin.hasOwnProperty(key)){ //剔除原型上的属性 target[key] = origin[key] } } return target;}var person2 = clone(person1);person2.name = '李沐子';person2.sex = 'female';person2.son.forth = 'Juck';console.log(person1);console.log(\" \");console.log(person2); 运行结果: 从运行结果看name和sex更改成功且不会影响到老对象但当增加son对象时,老对象还是会受到影响。总结: 浅拷贝处理不了对象里面的引用值 深拷贝使用Object.prototype.toString.call 和 typeof进行深拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 // 深拷贝 function deepClone(origin,target){ var target = target || {}, toStr = Object.prototype.toString, arrType = '[object Array]'; for(var key in origin){ // 判断key到底是不是origin本身的或是原型上的属性 if(origin.hasOwnProperty(key)){ // 判断是不是引用值，并且不等于 null if(typeof(origin[key]) === 'object' &amp;&amp; origin[key] !== null){ // 判断是对象还是数组 if(toStr.call(origin[key]) === arrType){ target[key] = []; }else{ target[key] = {}; } // 然后递归 deepClone(origin[key],target[key]); }else{ // 如果是原始值就直接赋值 target[key] = origin[key]; } } } return target; // 把新的target 返回出去 } Object.prototype.num = 1; var person1 = { name:'张三', age: 18, sex: 'male', son:{ fitst:'Jenney', second:'Lucy', third:'Jone' }, car:['Benz','Ferrari'] }var person2 = deepClone(person1);person2.name = '李四';person2.sex = 'female';person2.son.forth = 'Juck';person2.car.push('Mazda');console.log(person1);console.log(\" \");console.log(person2); 运行结果: 实现过程： 使用for循环遍历剔除prototype上的自定义的属性/方法 在循环里面判断哪个是引用值和原始值并且不能是null 不是引用值就直接赋值，如果是引用值再使用Object.prototype.toString.call判断是对象或是数组。 如果是对象则target赋值一个空对象，否则就赋值一个空数组 然后使用递归 deepClone(origin[key],target[key]) 最后把新的 target 返回出去 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"https://cokesprit.gitee.io/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"利用原型深度封装typeof方法","date":"2020-08-19T10:02:10.000Z","path":"/posts/1dce70fc/","text":"在开发中有时候我们需要判断属性的具体类型,而系统给的typeof不足以去判断属性的具体类型，我们需要利用原型来对typeof进行深度封装。typeof返回值有：number string boolean object function undefined 以字符串的形式返回。 123456789101112131415161718192021222324252627282930313233function myTypeof(){ var type = typeof(val); // 使用typeof判断val的类型 var toStr = Object.prototype.toString; // 存入结果集 var res = { '[object Array]':'array', '[object Object]':'object', '[object Number]':'object number', '[object String]':'object string', '[object Boolean]':'object boolean', } if(val === null){ return 'null'; }else if(type === 'object'){ // 返回引用值的具体类型 var ret = toStr.call(val); return res[ret]; }else{ return type; }} console.log(myTypeof(1)); console.log(myTypeof('s')); console.log(myTypeof(true)); console.log(myTypeof({})); console.log(myTypeof([])); console.log(myTypeof(new Number(1))); console.log(myTypeof(new String(1))); console.log(myTypeof(new Boolean(1))); console.log(myTypeof(function(){})); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"烧脑的this指向问题","date":"2020-08-19T03:11:39.000Z","path":"/posts/2198d04d/","text":"对于很多的初学者this指向确实是一个让人比较头痛的问题，一般this指向分为几种情况:1.在全局的时候2.普通函数里面3.构造函数的this指向4.apply/call下面我们就来举例说明以上情况的的this指向问题 在全局的时候123var d = 3;console.log(this.d); console.log(window.d); 运行结果： 从上面的运行结果可以看出二者输出的结果是相同的这样说明全局下的this -&gt; window 预编译函数(普通函数)12345678function test(b){ this.d = 8; var a = 2;}test(123);console.log(this.d);console.log(window.d); 运行结果： 查看运行结果发现它们的结果是一样的这就说明,在普通函数的内部只要没有实例化这个函数的this是默认指向window的。 构造函数内部1234567891011121314151617181920 function Test(){ this.name = 'niming'; } var test = new Test(); // 预编译期的过程 // GO = { // Test:function test(){...} // test:{} // } // AO = { // // 前面我们说了普通函数没new之前 this -&gt; window // this: window, // 当 new 的时候之前的 this 被覆盖 // this:{ // name:'123', // __proto__:Test.prototype // } // } 当预编译的时候 this -&gt; window,当 new 之前GO就已经把保存了 Test:function test(){…} 然后再保存 test:{},但是 new（AO开始） 的时候 Test构造函数内部隐式的 var 了一个 1234this = { name:'123', \\_\\_proto\\_\\_:Test.prototype} 并且覆盖了之前指向window的this,最后系统隐式的把这个新的this返回了出去被全局下的test接收到,从这里我没可以总结出来构造函数的this指向实例化对象 call/apply12345678910111213141516// call/apply的作用是更改this指向 function Person(name,age){ this.name = name; this.age = age; // Person使用了apply, 当Programmer实例化之后Personn内部属性变成 // p.name = \"张三\"; // p.age = 18; } function Programmer(name,age){ Person.apply(this,[name,age]); this.work = 'Programming'; } var p = new Programmer('张三',18); console.log(p) 运行结果: 因为Person使用了apply把自身构造函数内部的指this指向变成Programmer的实例化对象 p，所以打印p的时候 p 也有Person构造函数的属性。 总结：全局this -&gt; window预编译函数（普通函数）this -&gt; window构造函数的this指向实例化对象apply/call改变this指向 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"英语语法上","date":"2020-08-18T13:41:25.000Z","path":"/posts/9416cc31/","text":"课程设置 #### 一、简单句 #### 二、并列句 #### 三、从句 ##### 名词性从句 ##### 定语和定语从句 ##### 状语和状语从句 一、简单句what is 简单句？英语的句子必须具备主谓结构,并且主语一定是谓语动作的发出者如果有宾语的话宾语一定是谓语动作的承受者。 试译：我的英语说的很好;主：我谓：说宾：英语I speak English every well. 试译：我家住在玉林谓：住主：我I live in Yuli 试译：我要去剪头主：一个理发师谓：剪宾：我的头发 A barber will cut my hair.解析:这句话中我不能充当主语，因为动作的发出者不是我，动作的发出者是理发师所以理发师是主语 简单句的分类1.主谓2.主谓宾3.主谓表4.主谓双宾5.主谓宾宾补 主谓结构He died. We laugh(ed). 主谓宾谓语：实意动词 主系表谓语：系动词1.be2.感官动词：look smell sound taste feel;3.变化: become get4.保持: keep stay remain 上面所出现的都是主谓表结构，以外的都是主谓宾结构。 主谓双宾I bought him a dog说明：双宾就是两个宾语你是你我是我 主谓双宾和主谓宾宾补的区别就在于：需要在两 主谓宾宾补说明：宾补就是后面的那个单词对前面的那个单词的补充说明 主谓双宾和主谓宾宾补的区别:只需要在两个宾语之间加一个be动词，如果读起来意思是不对的就是主谓双宾，如果读起来意思是对的就是主谓宾宾补。 练习:We elect him our monitor.解题：在 him 和 our monitor之间加上be动词 变成 –&gt; We elect him is our monitor. 意思是对的所以是主谓宾宾补 句子的成分谓语 ***** 很重要!!!! (1)谓语的成分：有时态的实义动词或系动词充当谓语。 (2)动词能不能多？谓语只能是动词；动词只能做谓语,所以我们需要把一句话当中,所有不做谓语的动词全部都要变成不是动词。怎么把动词变成不是动词呢?①在动词后面加-&gt; ving -&gt; : ving表示主动②在动词后面加-&gt; ved -&gt; : ved被动③在动词前面加-&gt;to do -&gt; : to do 表示目的它们三个有个共同名字:小名叫做不是动词,大名叫做非谓语动词。 试译：他拍了拍我的肩膀,一句话都没说就离开了。He beating my shoulder,saying nothing departed当一句话有多个动词的时候,谁的意思最重要就选谁做谓语!!! 爱我就是 抱抱我Loving me is hugging (embracing) me. 我爱你,你爱我I loveing you,you love me. –&gt; 独立主格 例子：Beating you is my faultI enjoy watching TVMy dream is becomeing a teacherYour mother must be very beautiful; 二、并列句三、从句名词性从句定语和定语从句状语和状语从句 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"英语","slug":"英语","permalink":"https://cokesprit.gitee.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"Object.prototype.toString","date":"2020-08-18T10:10:59.000Z","path":"/posts/dc56b3a9/","text":"1234567// 同时都是toString()但打印出来的东西是不一样 console.log(Object.prototype.toString.call(1)); console.log(Object.prototype.toString.call(true)); console.log(Object.prototype.toString.call([1, 2, 3])); console.log(Object.prototype.toString.call({name:'张三'})); console.log(Object.prototype.toString.call(null)); console.log(Number.prototype.toString.call(1)); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"https://cokesprit.gitee.io/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"判断是否是数组的三种方法","date":"2020-08-18T09:13:23.000Z","path":"/posts/7a59e1cc/","text":"在开发中后端传过来的数据有可能是 null、对象、Array,有时候我们需要判断传回来是不是数组。 第一种使用 constructor 12var a = [];console.log(a.constructor); //ƒ Array() { [native code] } 运行结果: 第二种使用 instanceof 判断该对象是否是该构造函数构造出来的,是返回ture，否则返回false 1234var str = \"Hello word\"; var a = [];console.log(a instanceof Array);console.log(str instanceof Array); 运行结果: 第三种使用call和Object原型下的toString方法来进行判断,推荐使用这种！！！ 1234567891011121314151617181920// 把 Object原型下的toString方法赋给 strvar str = Object.prototype.toString, a = [];var trueTip = '[object Array]';// 然后利用call指向aif(str.call(a) === trueTip){ console.log('是数组');}else{ console.log('不是数组');}// 执行分析 // Object.prototype = { // toString:function(){ // // 没call 之前 // this.toString(); // // call 以后更改 this 指向 -&gt; a // a.toString(); // } // } 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"https://cokesprit.gitee.io/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"企业模块化开发","date":"2020-08-18T08:23:21.000Z","path":"/posts/adbaaf4/","text":"在开发的时候往往需要写很多功能模块,为了更好的协作开发需要采用模块化开发的方式,把这些功能分一个一个的分开来写最后汇总到一个大模块里。 模块化开发12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 第三步window.onload = function(){ init();}// 第二步function init(){ initCompute(); initFunctions();}// 第一步 // 功能一initCompute = (function(){ var a = 3, b = 4; function add(){ console.log(a + b); } function minus(){ console.log(a - b); } function mul(){ console.log(a * b); } function div(){ console.log(a / b); } return function(){ add(); minus(); mul(); div(); }})();// 第一步 // 功能二 var initFunctions = (function(){})(); 把功能全部封装到各自的自启动函数里面，然后分别赋给initCompute 和 initFunctions，再把他们放到一个总的init里面,最后再放到window.onload里面执行。 模块化练习使用模块化开发的实现两个功能:1.求n的斐波拉契数列2.输入一个数n求有打印那些可以被3获被5获被7获整除的数 123456789101112131415161718192021222324252627282930313233343536373839window.onload = function(){ init();}// 把每个模块放到init里面function init(){ console.log(initFb(10); console.log(initDiv(100);}// 斐波拉契数列var initFb = (function(){ function fb(n){ if(n &lt;= 0){ return 0; } if(n &lt;= 2){ return 1; } return fb(n-1) + fb(n-2); } return fb;})();// 被3或被5或被7或整除var initDiv = (function(){ function div(n){ var arr = []; for(var i = 0; i &lt;= n; i++){ if(i % 3 === 0 || i % 5 === 0 || i % 7 === 0){ arr.push(i); } } return arr; } return div; })(); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型继承之圣杯模式","date":"2020-08-17T11:27:04.000Z","path":"/posts/98829262/","text":"之前的那几种方案都不太尽人意,在解决继承,有专门的企业即解决方案圣杯模式。 圣杯模式12345678910111213141516171819202122232425262728293031function Teacher(){ this.name = 'Mr. Li'; this.tSkill = 'JAVA';}Teacher.prototype = { pSkill: 'JS/JQ';}function Student(){ this.name = 'Mr. Wang';}// 创建一个缓冲区介于 Teacher 和 Student之间function Buffer(){}Buffer.prototype = Teacher.prototype;var buffer = new Buffer();// Buffer 实例化出来之后没有属性和方法,// 但是它有Teacher.prototype// 然后把实例化对象buffer赋给Student.prototypeStudent.prototype = buffer;// 这样Student实例化出来的对象就能访问Buffer.prototype// 也能访问到Teacher.prototype// 这就是圣杯模式完美解决了继承和隔离的问题。Student.prototype.age = 18;var s = new Student();console.log(s); 运行结果： 圣杯模式封装为了方便使用我们把它封装起来,这样我们需要的时候直接调用就行了 123456789101112// 圣杯模式之封装var inherit = (function(){ var Buffer = function(){} return function(Target,Origin){ Buffer.prototype = Origin.prototype; Target.prototype = new Buffer(); // 为了还原构造器,把Target构造器重新指向 Student Target.prototype.constructor = Target; // 继承源 Target.prototype.super_class = Origin; }})(); 企业级的解决方案 -&gt; 这是雅虎当年在 YUI3 里面封装的一个方法,虽然 YUI3 已经不在了但是这个方法被留存了下来。 例子写一个程序员的构造函数，然后再写各写一个前端程序员和后端程序员的构造函数,并且这两个构造函数继承程序员这个构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 实现继承的方法var inherit = (function(){ var Buffer = function(){}; return function(Target,Origin){ Buffer.prototype = Origin.prototype; Target.prototype = new Buffer(); Target.prototype.constructor = Target; Target.prototype.super_class = Origin; }})(); // 采用模块化开发方式var initProgrammer = (function(){ var Programmer = function(){} // 把一些很少更改的属性和方法写到原型上 Programmer.prototype = { name:'程序员', tool:'计算机', work:'编写应用程序', duration:'10个小时', say:function(){ console.log('我是一名' + this.myName + this.name + \"我的工作用到\" + this.tool + this.work + \",我每天工作\" + this.duration + \" ，我的工作需要用到：\" + this.lang.toString() + \"。\"); } } function FrondEnd(){} // 前端工程师 function BackEnd(){} // 后端工程师 inherit(FrondEnd,Programmer); // 使用 inherit 实现继承 inherit(BackEnd,Programmer); FrondEnd.prototype.lang = ['HTML','CSS','JavaScript']; FrondEnd.prototype.myName = '前端'; BackEnd.prototype.lang = ['Node','Java','SQL']; BackEnd.prototype.myName = '后端'; // 把它们写在一个对象里面返回出去 return { FrondEnd:FrondEnd, BackEnd:BackEnd }})();// 实例化对象 var frondEnd = new initProgrammer.FrondEnd(); var backEnd = new initProgrammer.BackEnd(); frondEnd.say(); backEnd.say(); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"公共原型继承","date":"2020-08-17T10:15:36.000Z","path":"/posts/8f490e5b/","text":"使用call/apply这种方法也不尽人意,我在想我这样写行不行 123456789101112131415161718192021function Teacher(){ this.name ='Mr. Li'; this.tSkill = 'JAVA';}Teacher.prototype = { pSkill:'JS/JQ';}var t = new Teacher();console.log(t);function Student(){ this.name = 'Mr. Wang';} Student.prototype = Teacher.prototype; Student.prototype.age = 18; var s = new Student(); console.log(s); 运行结果: 把 Teacher 的原型赋给 Student 的原型，这样的话 Stduent 下的属性也可以拥有而且还可以拥有 Teacher 原型的下属性,并且没有继承Teahcer下的一些属性我们不需要的属性。 问题：这种方式也有一点不好的就是如果向 Student.prototype 增加属性和方法的时候也会添加的 Teacher.prototype 里面。因为它们两个指向同一个地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"借助call或apply实现继承","date":"2020-08-17T09:50:13.000Z","path":"/posts/18be6742/","text":"上篇使用原型链的方式来继承并不是很科学,像老鼠的名字就没有必要继承。这次我们使用call/apply实现继承。 1234567891011121314151617// call/applyTeacher.prototype.wife = 'Ms. Min';function Teacher(){ this.name = name; this.mSkill = mSkill;}function Student(name,mSkill,age,major){ Teacher.apply(this,[name,mSkill]); this.age = age; this.major = major;}var student = new Student('Mr. Li','JS/JQ/',18,'Computer');console.log(student);console.log(student.wife); // 访问不到Teacher.prototype下的属性 运行结果: 问题：这种方式不太像继承,叫借用更加贴切,而且这种方式访问不到Teacher.prototype,这种方式也不太理想。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型链继承","date":"2020-08-17T09:05:42.000Z","path":"/posts/31601a23/","text":"1234567891011121314151617181920212223242526 Professor.prototype = { name:'Mr. Li', tSkill:'JAVA' } function Professor(){} var professor = new Professor();// ---------------分割线----------------- // 把professor实例对象赋给 Teacher.prototype Teacher.prototype = professor; function Teacher(){ this.name = 'Mr. Mi'; this.mSkill = 'JS/Jq'; } var teacher = new Teacher();// ---------------分割线----------------- // 把 teacher实例对象赋给Student.prototype Student.prototype = teacher; function Student(){ this.name = 'Mr. Xiao'; this.pSkill = 'HTML/CSS'; } var student = new Student(); console.log(student); 运行结果： student 现在这个对象继承了 Teacher 上所有属性和 Teacher 原型上的属性,也继承了 Professor 原型上的属性。 总结：最下面的对象继承了上面原型链上的所有属性，这就是原型链继承。 问题：学生身上是否需要继承Teacher 和 Professor 上所有的属性或者原型上的属性?不需要,所以继承方案还不是特别理想。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"插件化编程开发初探","date":"2020-08-15T08:35:01.000Z","path":"/posts/e0979614/","text":"JS插件的写法1234567891011121314151617// JS 插件的写法 // 立即执行函数 -&gt; 防止变量污染 -&gt; 为了隔离全局作用域 ;(function(){ function Test(){ } // 开发中方法基本上都是写在原型上的 // 很少更改的东西也可以写到原型上 Test.prototype = { } window.Test = Test; // 挂到window上 })(); var test = new Test(); 练习12345678910111213141516171819202122232425262728// 传两个数字实现加减乘除的插件;(function(){ var Compute = function(opt){ } Compute.prototype = { plus:function(a,b){ return a + b; }, minus:function(a,b){ return a - b; }, mul:function(a,b){ return a * b; }, div:function(a,b){ return a / b; } } window.Comput = Compute; })();var comput = new Comput();var res = comput.div(2,2);console.log(res); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"Object.create","date":"2020-08-15T07:25:21.000Z","path":"/posts/3837d091/","text":"Obcet.create():创建对象,提供一个自定义原型的功能,参数是对象或者null。 参数是null时12var s = Objcet.create(null);console.log(s); // {} 运行结果： 总结:Object.create(null);创建的对象是没有原型的。 参数是对象时1234567891011121314151617var test = { num:2, say:function(){ console.log('今天天气真好'); }}function Obj(){}Obj.prototype.num = 1;var obj2 = new Obj();console.log(obj2);// 使用Object.create自定义原型var obj2 = Object.create(test); console.log(obj2);obj2.say(); 运行结果： 总结：Object.create 可以把其他的对象作为原型,形成一个祖先与后代的关系。使用Object.create()实现继承会更优雅一些。 面试/笔试不是所有的对象都继承于Object.prototypeObject.create(null)创建出来的对象没有原型所以不继承于Object.prototype document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型链","date":"2020-08-14T09:15:54.000Z","path":"/posts/bf8cf30/","text":"原型链原型链：沿着__proto__一层一层的去继承原型的属性所形成的链条,我们叫做原型链。 12345678910111213141516171819Professor.prototype.tSkill = 'JAVA';function Professor(){}var professor = new Professor();Teacher.prototype = professor;function Teacher(){ this.mSkill = 'JS/JQ';}var teacher = new Teacher();Student.prototype = teacher;function Student(){ this.pSkill = 'HTML/CSS';}var student = new Student();console.log(student); 运行结果: 我没有的属性我到我的原型上找,如果没有就一直往上找,这样就形成了一条链条。 补充所有的对象都有原型,包括原型的本身原型的顶端是Object.prototype!!!原型链上面的增删改只能是它自己本身!!!原型的原型是由系统自带的Object构造出来的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型","date":"2020-08-14T01:49:21.000Z","path":"/posts/263f3be4/","text":"原型涉及到构造函数和实例化对象,原型是在构造函数之上的,它也是构造函数的一个属性。 prototype和__proto__prototype：构造函数上的一个属性,只不过这个属性是一个对象而已 12345678910111213141516function Handphone(color,brand){ this.color = color; this.brand = brand;}Handphone.prototype.rom = '64';Handphone.prototype.ram = '6G';var hp1 = new Handphone('黑色','小米');console.log(Handphone.prototype); // 打印出来是一个对象// 原型prototype其实是function对象的一个属性// 这个prototype是构造函数构造出来的每一个对象的公共祖先console.log(hp1.rom); // 64// 所有被构造函数构造出来的对象都可以继承原型上的属性和方法 运行结果: constructorprototype的一个属性,指向构造函数本身 12345 function Handphone(color,brand,system){ this.color = color; this.brand = brand;}console.log(Handphone.prototype); 运行结果: 既然 constructor 指向的构造函数本身那我们来尝试一下让它指向其他的构造函数看可不可以 1234567891011121314 function Handphone(color,brand){ this.color = color; this.brand = brand;}function Telephone(color,brand,system){ this.color = color; this.brand = brnad; this.system = system;}Handphone.prototype = { // 让constructor指向另一个构造函数 constructor:Telephone}console.log(Handphone.prototype); 运行结果: constructor可以指向其他构造函数 __proto____proto__: 每一个实例化对象的原型容器,它就是装prototype的 123456789101112131415161718Car.prototype = { color:'白色', brand:'benz'}function Car(){ // 当构造函数实例化的时候 // 隐式的进行 // var this = { // __proto__: Car.prototype = { // color:'白色', // brand:'benz' // } // }}var car = new Car();console.log(car.__proto__);console.log(Car.prototype); 运行结果: 补充1.通过实例化对象更改自己的祖先是不行的2.所有被该构造函数构造出的对象都可以继承原型上的属性和方法3.prototype里面的constructor可以修改4.constructor 保存的是实例化之前的东西 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"https://cokesprit.gitee.io/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"instanceof","date":"2020-08-11T09:12:18.000Z","path":"/posts/instanceof/","text":"instanceof判断该对象是否是该构造函数构造出来的,是返回true不是返回false。 12345678910111213 function Car(){} var car = new Car(); function Person(){} var p = new Person();console.log(p instanceof Car); // false console.log(car instanceof Car); // true console.log(car instanceof Object); // true console.log([] instanceof Aarry); // true console.log([] instanceof Object); // true console.log({} instanceof Object); // true console.log({} instanceof Array); // false 总结：A对象的原型到底有没有B的原型,有的话就是 true,没有就是false。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面试/笔试","slug":"面试-笔试","permalink":"https://cokesprit.gitee.io/tags/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95/"}]},{"title":"in","date":"2020-08-11T08:58:35.000Z","path":"/posts/5fec8e4e/","text":"in 判断属性是否存在对象里。 123456var car = { brand:'Benz', color:'white'} // car对象不存在 displacementconsole.log('displacement' in car); // false in 不排除原型上自定义的属性。 12345678910var car = { brand:'Benz', color:'white'}Car.prototype = { displacement: '3.5'}var car = new Car();console.log('displacement' in car); // true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"hasOwnProperty","date":"2020-08-11T02:02:08.000Z","path":"/posts/hasOwnProperty/","text":"hasOwnProperty()如果对象具有指定名称的属性，则返回turn否则返回false 1234567891011121314151617181920212223242526function Car(){ this.brand = 'farrari'; this.color = 'red'; this.displacement = '6.0';} Car.prototype = { lang:5, width:2.5 } Object.prototype.name = 'Object'; console.log('第一次打印') // 连Car.prototype 和 Object.prototype 上自定义的属性都打印出来了 for(var key in car){ console.log(key + ' : '+car[key]); } var car = new Car(); console.log('使用了hasOwnProperty()方法之后') for(var key in car){ if(car.hasOwnProperty(key)){ console.log(car[key]); } } 运行结果： 总结：hasOwnproperty()主要用来找对象自身的属性,排除原型上自定义的属性 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"https://cokesprit.gitee.io/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"对象枚举","date":"2020-08-11T01:39:31.000Z","path":"/posts/1313d393/","text":"其实JavaScript并没有真正意义上的枚举,在 JavaScript 中有遍历就是有枚举。 对象的遍历使用 for…in 1234567891011121314151617// 使用 for...in var car = { brand:'Ferrari', color:'red', displacement:'6.0', lang:'5.5', width:'2.5'}for(var key in car){ // 重点！！！ // console.log(car.key); // 为什么打印 undefined？ // 因为 js 处理的时候是：car.key -&gt; car['key'] -&gt; undefined console.log(key + ' : ' + car[key]);} 运行结果： 数组是特殊的对象它也可以使用for…in来遍历 12345var arr = [1,2,3,4,5,6] ;for(var i in arr){ console.log(arr[i]);} 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"https://cokesprit.gitee.io/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"包装类","date":"2020-08-10T00:40:22.000Z","path":"/posts/52c58cb2/","text":"原始值没有自己的方法和属性！！！原始类型：Number、String、Boolean、Undefined、Null引用类型：Object、Function、Aarry、Date、RegExp 包装类12345678910111213141516171819var a = 1;a.len = 3;//a.len的时候系统转化成 ↓ // new Number(1).len = 3; new 前面没有东西接收, // 只能 delete 掉,所有打印 undefinedconsole.log(a.len); // undefined// 这时候我们就用到了包装类 // 变成实例化数字对象就可以有自己的属性和方法了var aa = new Number(1);aa.len = 3;console.log(aa.len); // 3// 经过 new Number 包装了之后再参与运算又会返回原始值var d = aa + 1;console.log(d); // 2// 像这种经过包装了之后再返回原始值的有三种 // new Number new String new Boolean 运行结果： 上面我们说了原始值是没有方法和属性的那下面这个又是怎么回事呢？ 1234567891011121314var str = \"abcd\";// 这又是怎么回事呢？console.log(str.length); // 4// 系统帮我做了如下的包装 ↓ new String(str).length; // String 是有length这个属性的,所以可以通过这样的包装来访问到String里面独有的属性 // 其实系统打印的是 console.log(new String(str).length); // 4// 面试如果别人问你字符串有没有 length 属性？ //记住字符串没有 length 属性 中间是经过了一层包装类 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"https://cokesprit.gitee.io/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"构造函数实例化的原理","date":"2020-08-06T03:10:47.000Z","path":"/posts/constructor/","text":"下面是构造函数实现实例化的原理,涉及到预编译、AO、GO、对象等知识 构造函数实例化的原理1234567891011121314151617181920212223242526272829303132333435363738 // 构造函数 function Car(color,brand){ // 第一步：系统会保存一个空的this对象 // this = {} // 第二步：系统将属性和方法写到 this 对象里面 // this = { // color:color, // brand:brand // } 和下面的一样 this.color = color; this.brand = brand; // 第三步：系统隐式的在后面加了 return this; 这一步很重要！！！ // return this; } // new 负责把this造出来和把原本指向window的this,转向实例化的对象 var car1 = new Car('黑色','兰博基尼'); console.log(car1.color,car1.brand);// GO 和 AO // GO = { // Car:(function), // car1:{ // color:'黑色', // brand:'兰博基尼' // } // } // AO = { // this:{ // color:color, // brand:brand // } // } 图一 自己实现构造函数的功能既然我们知道 new 仅仅是帮我们把 this 造出来和改变this的指向,那我们是不是可以不用 new 和 不使用 this 实现构造函数的功能? 1234567891011121314151617// 按照上面实例化的原理步骤我们来尝试一下是否可行function Car(color,brand){ // 第一步保存一个空对象 obj var obj = {} // 第二步将属性和方法写到 obj 对象里面 obj.color = color; obj.brand = brand; // 第三步 return obj return obj; }var car = Car('红色','法拉利');console.log(car.color,car.brand); 图二 从图一和图二看出它们两者并没有什么不同,我们是可以自己实现构造函数实例化的功能的。 有趣的如果我们在最后return 的时候改变为其他值呢?最后的结果会发生什么变化? 12345678910111213141516function Car(color,brand){ this.color = color; this.brand = brand; // 逐一尝试 return 不同的结果 return 'abc'; // return 123; // return {}; // return function(){} // return []}var car = new Car('白色','宝马');console.log() 图三 图四 总结:构造函数 return 出来原本是隐式的this,如果我们故意 return 了引用值那么它就是引用值,原始值的话this指向是不受影响的还是this。 引用值:Object、Function、Array、Date、RegExp 原始值: Undefined、Null、Boolean、Number 和 String document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"https://cokesprit.gitee.io/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"window.xxx=xxx 与 return xxx的区别","date":"2020-08-05T02:40:50.000Z","path":"/posts/8b19ee89/","text":"区别: 使用 return 出去后需要把执行函数赋值给一个全局变量,然后再执行这个全局变量的函数 使用 window 直接将函数保存到GO。既把函数保存到 window 上的一个变量,然后再执行 window 上变量所对应的函数。 下面来举例说明 123456789101112 // 使用return xxxvar add = (function (){ var a = 1; function add(){ a++; console.log(a); } return add; // 把内部的add函数返回给全局变量add})();add();add();add(); 运行结果: 123456789101112// 使用window.xxx = xxx(function (){ var a = 1; function add(){ a++; console.log(a); } window.add = add; // 把内部的add函数保存到window.add上})();add();add();add(); 运行结果: 从上面的例子可以看出window.xxx = xxx 和 return xxx 二者是结果是一样,使用window.xxx = xxx 也是可以形成闭包。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"闭包","slug":"闭包","permalink":"https://cokesprit.gitee.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"闭包基础","date":"2020-08-04T02:30:39.000Z","path":"/posts/3d615767/","text":"闭包的定义：当内部函数被返回到外部并保存时,就一定会形成闭包。 闭包的优点: 避免全全局变量的污染; 私有成员的存在; 希望一个变量长期存储在内存中。 闭包的缺点: 闭包会产生原来的作用域链不释放。 过渡的闭包可能会导致内存泄漏或加载过慢,因为它常驻内存。 闭包的用途:可以用来做数据缓存。 闭包的三个特性: 函数嵌套函数。 函数内部可以引用外部的参数和变量。 参数和变量不会被垃圾回收机制回收。 栗子1234567891011121314function test1(){ function test2(){ var a = 3; console.log(x); } var x = 2; return test2;}var b = 4;var test3 = test1();test3(); // 2// 这就是一个简单闭包 练习面包管理器 123456789101112131415161718192021function breadMgr(num){ var breadNum = arguments[0] || 10; function supply(){ breadNum += 10; console.log(breadNum); } function sale(){ breadNum--; console.log(breadNum); } return [supply,sale];}var breadMgr = breadMgr(60);breadMgr[1](); // 售出breadMgr[1](); // 售出breadMgr[1](); // 售出breadMgr[0](); // 补给 运行结果: 星期天计划管理器 123456789101112131415161718function sunSched(){ var sunSched = ''; var operation = { setSched: function(thing){ sunSched = thing; }, showSched: function(){ console.log(\"My schedule on sunday is \" + sunSched); } } return operation; // 把对象返回出去}var sunSched = sunSched(); //执行返回 operationsunSched.setSched('studying');sunSched.showSched(); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"闭包","slug":"闭包","permalink":"https://cokesprit.gitee.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"作用域与作用域链图解","date":"2020-08-03T01:42:56.000Z","path":"/posts/ab6a816/","text":"作用域与作用域链 栗子一123456789function a(){ function b(){ var b = 2; } var a = 1; b();}var c = 3;a(); 图解当a函数被定义时 当a函数被执行时(前一刻) 当b函数被定义时 当b函数被执行时(前一刻) 当b函数被执行结束后 回归b函数被定义时的状态 当a函数被执行结束时 回归a函数被定义时的状态 以上这就是作用域和作用域链的最基本的一个形态 栗子二这个例子比较特殊涉及到闭包,有关闭包的在下一篇更新。 123456789101112function test1(){ function test2(){ var b = 2; console.log(a); } var a = 1; return test2;}var c = 3;var test3 = test1();test3(); 当test1函数被定义时 当test1函数被执行时(前一刻),函数test2被定义 当test1函数被执行结束时 这时test1的AO并没有被销毁只是把线剪断了,test1的AO本该是要被销毁的,但test2已经被返回到外部且死死的抓住test1的AO不放,所有test1的AO不能销毁。注意这里是重头戏,这时候就形成了闭包了！！！ test3执行 test3执行结束时 这时的 test3 === test2。a是在test1的AO里面的,为什么可以打印出来a? 就像之前讲的test2还死死的攥着test1的AO,当在自己的AO上没有查找到,则去test1的AO查找,实际操作的仍然是test1的AO。 补充 每个函数在定义的时候就已经保存了全局上下文GO。 函数自己的AO产生了,就会把自己AO排在作用域链的最顶端,其他AO和全局GO就会被挤下去。 函数被定义的时候它拿的是它上一级的作用域链。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"https://cokesprit.gitee.io/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"作用域之对象的隐式属性[[scope]]","date":"2020-08-02T13:13:15.000Z","path":"/posts/scope/","text":"[[scope]] -&gt; 作用域，它是函数创建时，生成的一个JS内部的隐式属性，这个属性只能由JS引擎来读取的。 [[scope]] [[scope]]它是函数创建时,生成的一个JS内部的隐式属性。 [[scope]]它是存储函数作用域链的 容器,作用域链存储的是AO/GO。 GO:全局执行期上下文AO：函数执行期上下文，当函数执行完成以后，AO是要销毁的,如果再次执行这个函数的时候AO会重新生成而且这个AO是新的AO。也就是说每一次执行会生成一个新的AO，原来老的AO在函数执行完以后它就会被销毁，也就是说AO是一个即时的存储容器;它不是长期保存的，它是根据函数的执行周期来保存。而作用域链其实就是把这些AO/GO形成链式从上到下排列起来,形成一个链式关系,这个链式关系其实就是作用域链。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"https://cokesprit.gitee.io/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"搬砖日记","date":"2020-07-27T04:54:14.000Z","path":"/posts/tote-bricks/","text":"前言为什么选择去工地搬砖,而不是去广东进厂?1.我大伯接了一个工程,挺赶的,人手不够。2.去广东的话车费来回要六百块,不划算。3.进厂一天十二个小时感觉有点吃不消,且一天没有多少学习时间。 第一天2020-07-27-14:00整就被家里人叫去工地帮忙。到哪要干的事很简单,只需要把砖,水泥、碎石杂、沙子放到斗车里,然后拉到吊机下面给吊机吊上楼顶。晚上七点钟下班感觉身体有点吃不消,手脚都有点酸;可能是太久没干重体力活的原因,想想过几天适应了可能就好受点。晚上十点钟时就有一股深深的困意袭来,虽然很困,但还是把今天的任务完成。 第二天2020-07-28早上六点四十分起来时感觉全身酸痛,手还有点发抖。今天要上一整天的班,上班时间为上午7:00 - 12:00,下午14:00 - 19:00一共十个小时;相比于进厂的话要好一点,晚上还能有一些时间留给自己。 今天还是重复昨天的工作把砖,水泥、碎石杂、沙子放到斗车里,然后拉到吊机下面给吊机吊上楼顶。对我来说沙子是最难弄的,要把沙子铲到斗车里面去。沙子有点湿再加上我左手腕有暗伤,打篮球的时候伤的时间有两个月了,我以为好了;谁知道当把沙子铲到铲里提起来时,左手直接软了提不起来,没办法只能一点点的铲了。晚上洗完澡躺倒床上,有点那种倒头就睡的冲动,今天要比昨天累很多。 第三天2020-07-29今天是我搬砖的第三天,天空很蓝,云朵很大,风很舒服,太阳很晒。今天的砖头比昨天格外的烫手,对面超市的冰镇可乐,依然是我不敢奢求的梦想,微分吹过我的脸庞,我很迷茫。 第四天2020-07-30中午下来一场雨,浸透了燥热的天空。让着原本燥热不堪看的气温竟夹带着一丝凉意,深深的呼吸新鲜空气,带着淡淡泥土的芬芳;让我这疲惫的身躯,重新焕发了一丝活力。下午的时候吊机出了一点问题,吊不起太多东西了,这使得我的工作轻松了许多,但无聊的时候,也是时间最漫长的时候,在这短暂而又漫长的时间里我会想着我昨天的代码和我的未来该何去何从~~~~ 第五天2020-07-31做了几天身体也渐渐适应了工作强度,手脚也不酸痛了。说说这几天的改变吧。最直观就是黑了很多就几天时间晒得跟包大人一样,我对着镜子又陷入了沉思,看来老天爷也不想让我白活一辈子。 身体素质上得到了小幅提升比如说手部力量和腿部力量,感觉比以前有力很多。不光这些连我的睡眠质量也得到了很大的改善,无论是晚上睡觉还是午休我都可以快速入睡,这是在学校时所没有的。这是几天搬砖最大的“收获”,有点困了今晚就这样了。 第六天2020-08-01今天是建军节。太阳出奇的大,气温是我从开始到现在最热的一天气温高达34度,感觉都要化了。不过还好今天不是很忙,今天楼上的砖差不多都砌完了,明天过后就会轻松很多。 第七天2020-08-02天气还可以不怎么热风很凉快,六点钟的时候下了场雨挺大的。无奈只能“暂停营业”,提前下班。 第八天2020-08-03今天建设局的人来检查,说违规建设未经允许私自加高楼层。听说这这个房子的主人只申请到了到了六层楼的文件建设许可,现在起到第八层局里的人说得拆掉两层,现在这栋房子的主人正在与局里的人沟通,估计明天也出不来结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搬砖日记","slug":"搬砖日记","permalink":"https://cokesprit.gitee.io/tags/%E6%90%AC%E7%A0%96%E6%97%A5%E8%AE%B0/"}]},{"title":"GO和AO","date":"2020-07-25T13:43:05.000Z","path":"/posts/GO-AO/","text":"GO: global object 全局的执行期上下文AO：activation object 活跃对象,函数的执行期上下文 暗示全局变量暗示全局变量 -&gt; imply global variable 12345678910111213141516171819202122232425// 栗子一 var a = 1; b = 2; // 暗示全局变量 不使用 var console.log(window.a); console.log(window.b); // a = window.a // b = window.b // window = { // a:1 , // b:2 // }// 栗子二 function test(){ var x = y = 7; } test(); console.log(y); // 打印 7 , 未声明直接赋值,提升成全局变量 // window 本身是一个全局的域;所有的全局变量都归 window 所有 // 你也可以这么认为 全局变量是 window对象的属性,全局函数是 window对象的方法 运行结果： 全局变量与GOjs在执行之前会产生一个叫GO的东西，GO又叫 -&gt; global object -&gt; 全局的执行期上下文 GO执行： 1. 找变量声明 2. 找函数声明 3. 执行 1234567891011121314// 栗子一 var a = 1; function a(){ console.log(2); } console.log(a); // 1 // 根据上面GO执行一步一步的来 // GO = { // a: undefined // a: function a(){} // a: 1 // } // 总结： GO === window,GO只关注全局变量的和全局函数声明并不关注函数的内部; 1234567891011// 栗子二 console.log(c,d); // 打印 f c(){} undefined function c(){} var d = funciton(){} // GO 执行 // GO = { // d:undefined // 第一步 找变量 // function(){} // c:function c(){} // 第二步 找函数声明 // } 疑点解析：为什么打印d是undefined并不是 f c(){}?因为预编译的时候是去找变量声明和函数声明,当编译完后才解释一行,执行一行。 总结：在使用 GO 的时候要考虑执行顺序。 函数预编译与AO函数预编译其实就是在函数执行之前要进行的一个步骤它这个步骤叫做AO：AO - &gt; activation object -&gt; 活跃对象 -&gt; 函数的执行期上下文 。它先创建AO这个对象AO = { }然后把形参和变量什么声明放到里面去，即AO执行： 寻找形参和变量声明 实参值赋值给形参 找函数声明,赋值 执行 123456789101112131415161718192021// 栗子一 function test(a){ console.log(a); // ƒ a(){} var a = 1; console.log(a); // 1 function a(){} var b = function(){} console.log(b); // ƒ (){} function d(){} } test(2); // AO = { // a: undefined -&gt; // 2 -&gt; // function a(){} -&gt; // 1 // b: undefined // function (){} // d: function d(){} // } 运行结果： 12345678910111213141516171819202122232425262728// 栗子二 function test(a,b){ console.log(a); // 1 c = 0; var c; a = 5; b = 6; console.log(b); // 6 function b(){} function d(){} console.log(b); // 6 因为 b = 6; 把函数式 function b(){} 给覆盖了 } test(1); // AO = { // a: undefined -&gt; // 1 -&gt; // 5, // b: undefined -&gt; // function b(){} -&gt; // 6, // c: undefined -&gt; // 0, // d:function d(){} // } 运行结果： 练习题写出练习例子的GO和AO 练习一12345678function test(){ return a; a = 1; function a(){} var a = 2; }console.log(test()); // ƒ a(){} 练习二1234567console.log(test()); //2function test(){ a = 1; function a(){} var a = 2; return a;} 练习三123456789101112131415161718192021 a = 1 ;function test(e){ function e(){} arguments[0] = 2; console.log(e); if(a){ var b = 3; } var c ; a = 4; var a; console.log(b); f = 5; console.log(c); console.log(a);}var a;test(1);console.log(a); //1console.log(f); //5 补充预编译是不看 if的,看见有声明就挂上去。if只有在在执行的时候才去看 if 。但是if 内部的变量声明还是看的。 为啥了解AO和GO为了解决js作用域/作用域链相关所产生的一切问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"https://cokesprit.gitee.io/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"预编译","date":"2020-07-25T07:37:53.000Z","path":"/posts/ab96ffb5/","text":"JavaScript在执行之前有几个步骤: 检查通篇的语法错误 预编译的过程 解释一行,执行一行 预编译代码演示 12345678910test(); // 2function test(){ console.log(2);}console.log(a); // undefined 如果不声明a然后直接打印的话就会报错var a = 10; // var a = 10 ; // 是2个步骤 编译时找a并且赋值undefined -&gt; 执行时赋值 10 运行结果： 上面的演示中test();打印出来了2,而console.log(a);打印出来了undefined并没有报错,证明 js引擎在编译的时候,先去找函数声明,和变量声明,而变量赋值并不是在编译的时候做的,而是在编译完成后执行到那句时做的。 总结：函数声明是整体提示的(函数内部的东西),变量只有声明提升,变量赋值不提升。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"https://cokesprit.gitee.io/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"callee-caller","date":"2020-07-24T10:45:47.000Z","path":"/posts/callee-caller/","text":"calleecallee是arguments的属性,代表当前函数的引用(名字),在函数内部使用，主要用来配合立即执行函数。接下来让我们来认识 callee 12345678910function test(a,b,c){ console.log(arguments.callee); //打印的是这个函数本身 // 这两组是一样的 console.log(test.length);// 打印形参的长度 console.log(arguments.callee.length);//打印形参的长度 console.log(arguments.length);// 打印实参的长度}test(1,2); 运行结果： callee 配合立即执行函数 12345678// 使用递归求 n-1 的累加和 var sum = (function(n){ if(n &lt;= 1){ return 1; } return n + arguments.callee(n-1);}(10));console.log(sum); 运行结果： caller返回当前被调用的函数的引用这听起来有点绕,让我们使用代码来更好的理解 1234567891011function test1(){ test2();}function test2(){ console.log(test2.caller); //这里打印的是 test1,因为test1()调用了test2并且test1执行了。 // 在被调用函数里面打印被调用函数的caller 它可以打印出谁在调用它。 // 注意一定是要被真正执行才能打印出来！！！}test1(); 运行结果： 注意在严格模式下 callee 和 caller 会报错!!! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面试/笔试","slug":"面试-笔试","permalink":"https://cokesprit.gitee.io/tags/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95/"}]},{"title":"call/apply方法","date":"2020-07-24T04:20:37.000Z","path":"/posts/call-apply/","text":"作用：call() 和 apply() 都是用来更改 this 指向;call()：call(this指向的对象, 参数1, 参数2, 参数n);apply()：apply(this指向的对象, []);不同之处：apply() 第二个参数是数组,实际开发中用的比较多的是apply(); 栗子栗子一让 newCar1和newCar2 拥有Car构造函数的的所有属性以及方法 1234567891011121314151617181920// Car function Car(brand,color){ this.brand = brand; this.color = color; this.run = function(){ console.log(this.color+\"的\"+this.brand+\"正在行驶\"); }} var newCar1 = { pdiliang:'3.0' }; var newCar2 = { pdiliang:'2.0' }; Car.call(newCar1,\"奔驰\",\"白色\"); console.log(newCar1); Car.apply(newCar2,[\"五菱宏光\",\"米色\"]); console.log(newCar2); 运行结果：可以看到 newCar1 和 newCar2 拥有了Car的属性和方法 栗子一讲解：12345678910// 当使用 newCar1/newCar2 的时候 Car 变成内部的情况是这样的function Car(){ newCar1.brand = brand; newCar1.color = color;}function Car(){ newCar2.brand = brand; newCar2.color = color;}// 因为 call/apply更改了 this 的指向 栗子二买车案例 1234567891011121314151617181920212223242526272829// 买车案例function Car(brand,color,displacement){ this.brand = brand; this.color = color; this.displacement = displacement; this.info = function(){ return '排量为'+ this.displacement + '的' + this.color + this.brand; }}function Preson(opt){ // 借用 Car 的属性和方法 Car.apply(this,[opt.brand,opt.color,opt.displacement]); this.name = opt.name; this.age = opt.age; this.say = function(){ console.log( '年龄'+ this.age + '岁姓名为'+this.name+'买了一辆'+this.info() ); }}var pt = new Preson({ brand:'法拉利', color:'红色', displacement:'3.5', name:'黄一蓝', age:'20'});pt.say(); 运行结果： call() 和 apply()的使用场景 以前写了一个功能不太完整，这时候可以写一个新的功能来补充完整，这个时候呢就可以使用 call() 和apply() 这两个方法去借用，以前功能相对应的方法和函数。 在工作的过程中很多人一起写个大功能，这个时候可以分组来写，最终统一去调用,一起协同作战。 分类：比如写一个东西，它有几种不同的类型，我们就可以分开写最后汇总。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面试/笔试","slug":"面试-笔试","permalink":"https://cokesprit.gitee.io/tags/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95/"}]},{"title":"立即执行函数","date":"2020-07-22T13:13:45.000Z","path":"/posts/iife/","text":"立即执行函数：解释：自动执行，执行完成立即释放（销毁） 英文：Immediately - Invoked Function Expression 简称：IIFE 作用：创建一个独立的作用域 好处：可以避免函数内的变量暴露在全局环境下，避免全局变量的污染。写法123456789// 写法一(function(){ })(); // 常用写法// 写法二(function(){}()); // w3C建议 演示错误声明12345678910 // 错误声明function test(){ console.log(\"这样是错误的声明\")}(); // 因为解析的时候是 ↓ function test(){ } (); //括号里面是空的会报错,当有值的时候会解析成一个表达式。 正确声明1234// 正确声明 var ts = function (){ // 这个匿名函数赋值给了 ts 这是一个赋值的过程 console.log(\"这样可以执行！\"); }(); 证明立即执行函数完就销毁1234567// 证明立即执行函数的销毁var testone = function(){ console.log(\"%c 1\",\"color:red;background:pink;\"); }(); // 这是一个赋值的过程 并不是执行所以可以这样写console.log(testone);//打印 undefined // 打印 undefined 证明 testone 在执行完之后就被销毁了 例子1234567891011// 例子一 (function(a,b){//这两个是形参 console.log(a+b); 6 }(2,4));//这两个是实参 // 例子二 var sum = (function(a,b){ return a + b; }(3,4)); console.log(sum); // 7 总结1.括号括起来的都是表达式,不管里面是什么;2.只有表达式才能被执行符号(括号)执行;3.把函数声明变成表达式，那么你的函数名就会被自动的忽略; 扩展函数声明变成表达式的方法函数声明变成表达式的方法在 function前面加 + 、- 、！、||(前面得加 0)、&amp;&amp;(前面得加 1) 12345678+function(){ console.log(\"我前面加了 + 号变成表达式了,所以可以立即执行\");}();0||function(){ console.log(\"我前面加了 0|| 运算符,我也变成表达式了,我也可以立即执行了。\");}(); 逗号运算符12345// 逗号运算符 // 逗号运算符只返回,所有逗号的最后一个值 // 例子： console.log((6-7,8+9,5+5)); // 10 console.log((4,5,7)); // 7 面试题1234567891011// 面试题function tst(a){ // console.log(\"不报错，也不运行\");}(6);// 解析流程 // 因为解析的时候是解析成两部分的 function tst(){ } //解析这是一个函数 (6); //这个(6),解析成一个表达式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"https://cokesprit.gitee.io/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"递归","date":"2020-07-21T08:23:14.000Z","path":"/posts/digui/","text":"什么是递归？递归说白了就是，函数自己调用自己。 递归主要的两个部分1.找到计算的规律!2.找到一个出口,让它结束掉! 栗子栗子一求 n 的阶乘 -&gt; 不能使用 for 循环 12345678910111213141516171819202122232425262728// fact(n);// 规律：n = n * fact(n-1)// 出口：n === 1 function fact(n){ //出口 if(n === 1){ return 1; } // 规律 return n * fact(n - 1); } console.log(fact(5));// 解析 // 当 n = 5; // 120 = fact(5) = 5 * fact(4); -&gt; 5 * 4 * 6; // 24 = fact(4) = 4 * fact(3); -&gt; 4 * 3 * 2; // 6 = fact(3) = 3 * fact(2); -&gt; 3 * 2 * 1; // 2 = fact(2) = 2 * fact(1); -&gt; 2 * 1 * 1; ↑ // 当程序走到出口1的时候又往上执行， // 因为上面还有一大堆队列都没有实际的运算结果，但是一到 1 // fact(1) = 1 然后 // 2 * 1 等于 2； fact(2) 等于 2; // 3 * 2 等于 6; fact(3) 等于 6; // 4 * 6 等于 24; fact(4) 等于 24; // 5 * 24 等于 120; fact(5) 等于 120; 栗子二斐波拉契数列 123456789101112131415161718192021222324252627//规律: n3 = n2 + n1;//出口：n &lt;= 0 n &lt;= 2; function fb(n){ // 两个出口 if(n &lt;= 0){ return 0; } if(n &lt;= 2){ return 1; } // 规律 return fb(n-1) + fb(n-2); } console.log(fb(6)); // 解析: // 斐波拉契数列： 0,1,1,2,3,5,8,13.... 像这种规律的。 // 规律：n3 = n2 + n1 // 出口：n &lt;= 0 n &lt;= 2 // n = 6; // 8 = fb(6) = fb(5) + fb(4); -&gt; 5 + 3 // 5 = fb(5) = fb(4) + fb(3); -&gt; 3 + 2 // 3 = fb(4) = fb(3) + fb(2); -&gt; 2 + 1 // 2 = fb(3) = fb(2) + fb(1); -&gt; 1 + 1 ↑ 总结递归它总是走到出口的时候,再向上一步一步的赋值计算后返回结果. 注意递归会涉及到性能的问题,return 的值一直出不去,要等执行到出口的时候。递归处理一些,小逻辑还是可以的,但是JavaScript里慎用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"https://cokesprit.gitee.io/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"js实参求乘积","date":"2020-07-19T07:25:53.000Z","path":"/posts/js-shican-qiu-chengji/","text":"在解题之前我们先搞懂什么是js中的形参和实参？ js中的形参和实参12345678 // 形式参数 形参function test(形参1,形参2){ // 里面的就是形参 console.log(test.length); // 形参长度 console.log(arguments.length);// 实参长度}// 实际参数 实参test(实参1,实参2,实参3);补充 形参和实参数量可以不相等。 arguments 是一个对应于传递给函数的参数的类数组对象里面包含所有的实参!!! 实参里面传了值的可以在函数内部修改实参的值，如果实参里面并没有传入值，也给形参赋值了，这样是没有用的。 js实参求乘积了解了什么实参和形参接下来就可以愉快的码代码了 123456789function sum(){var a = 1;for(var i = 0; i &lt; arguments.length;i++){ a *= arguments[i];}console.log(a);}sum(1,2,3,4); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js面试题","slug":"js面试题","permalink":"https://cokesprit.gitee.io/tags/js%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"ASCII码 和 UNICODE码","date":"2020-07-19T02:18:33.000Z","path":"/posts/504aee57/","text":"ASCII码0-127占一个byte大小，UNICODE码涵盖ASCII码 255 以后就占两个 byte大小。 练习 写一个函数，接收任意一个字符串，算出字符串的总字节数。 1234567891011function getBytes(str){ var sth = str.length; for(var i = 0; i &lt; str.length; i++){ var stc = str.charCodeAt(i); if(stc &gt; 255){ sth++; } } return sth;}console.log(getBytes('Hello js，我们做好朋友吧！')); 实现思路先获取到字符串的长度,将其存入一个变量 sth ,然后利用循环判断编码是否大于 255 ,如果大于 sth++ 。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"https://cokesprit.gitee.io/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"逻辑运算符","date":"2020-07-18T12:28:03.000Z","path":"/posts/17278be4/","text":"逻辑运算符：与&amp;&amp; 或|| 非! 在讲这个三个之前,先来认识js当中表示假的：undefined 、null、 NaN 、0 、false 、”” ，除上述以为全部都是真。 逻辑运算与：&amp;&amp;&amp;&amp;: 遇到真就会继续往前走，遇到假或者走到最后就返回当前的值。 12var a = 1 &amp;&amp; 2 &amp;&amp; undefined &amp;&amp; 10;console.log(a); 运行结果: 逻辑运算或： ||||:遇到假就会继续往前走,直到遇到真或者走到最后返回当前的值。 12var b = 0 || null || 1 || 0;console.log(b); 运行结果: 逻辑运算符非：!非就是取反，如果是真取反之后就是假，如果是假取反之后就是真。 1234567891011 var a = !true; // true 取反 -&gt; false console.log(a); var b = !1; console.log(b) var c = !c;/*注意此时的 c 未赋值还是 undefined , undefined取反就是真*/ console.log(c); //true 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"https://cokesprit.gitee.io/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo博客发布踩坑","date":"2020-07-18T02:29:37.000Z","path":"/posts/ffafe98e/","text":"hexo博客 Username for ‘https://github.com 验证问题这时候 输入你的github邮箱账号 （不是你的github名！！！） 之后会弹出一个提示框 然后输入邮箱登录密码即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"hexo","slug":"hexo","permalink":"https://cokesprit.gitee.io/tags/hexo/"}]}]