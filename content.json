[{"title":"ES5严格模式","date":"2020-08-28T09:08:36.000Z","path":"/posts/654e1570/","text":"ES5的严格模式,是ECMAScript要求对严格模式要强调，因为他们希望我们能够严格遵守ES5的语法和各种方法使用的规定，为ES6做铺垫。 ECMAScript发展历程97年 1.098年 2.099年 3.0 -&gt; JS通行标准这三年发展非常快，这ES3.0几乎奠定了ES5的大部分内容,其实ES5几乎全是ES3.0的内容,ES3.0到现在为止都统治着JavaScript，实际上ES5.0并没有对ES3.0进行十分多的更新。4.0 去了哪呢? 07年 4.0 -&gt; 太过激进 -&gt; 浏览器厂商不接受雅虎和微软都非常反对。 08年 4.0 中止（中止并不等于废除）：把一部分容易改善的部分放到了ES3.0,发布了3.1一些比较激进的部分给了一个版本代号 Harmony -&gt; 开了这个会后 ES3.1 -&gt; 更名为ECMAScript5.0，但是更改了之后ECMAScript5还是没有发布。 09年 5.0发布 Harmony -&gt; 分成连部分：1.一部分是激进当中不那么激进的部分 -&gt; 更名为 JS.NEXT2.激进部分 -&gt; JS.next.next 11年 5.1 ISO国际标准 -&gt; 而且这个5.1几乎还是基于3.0的标准 13年 ES6 = js.next js.next.next 放到es7里面 13年 ES6 草案发布 15年 ES6 正式发布 -&gt; ES6又名ECMAScrit2015 ES5的两个运行模式：正常模式 严格模式IE9及以下不支持严格模式 为什么要有严格模式？这是一个历史遗留问题,3.0太早了99年的,语法的严谨性和合理性有不足的地方,语法怪异安全性不足。 如何使用严格模式“use strict” 如果是脚本启动就是写在最上面的一行 还有一种就是写在函数里面,这很多大厂都这样写 123function test(){ 'use strict'} 严格模式有那些影响在严格模式下有一些属性是不能使用的例如：caller、callee、with、arguments下的大部分属性都是不可以用的,注意arguments是可以用的。 严格模式下this指向非严格模式下函数内部的this指向window 严格模式下如果函数没实例化this指向undefined,new 实例化之后this就指向该构造函数 123456// 没实例化之前严格模式下this指向\"use strict\"function test(){ console.log(this);}test(); 运行结果： 123456// 实例化之后\"use strict\"function test(){ console.log(this);}var test1 = new test(); 运行结果： 严格模式下call非严格模式下call()里面填的原始值的话它会经过包装类成为对象 12345// \"use strict\"function test(){ concole.log(this); // }test.call(1); 运行结果： 函数的参数不能重复命名非严格 -&gt; 不报错严格模式 -&gt; 报错 -&gt; 严格模式下函数参数不能重复命名 12345\"use strict\"function test(a,a){ console.log(a);}console.log(1,2); 运行结果： 笔试题严格模式 -&gt; 对象命名不允许重复但 -&gt; 不报错 123456\"use strict\"var obj = { a: 1, a: 2}console.log(a) 运行结果： 严格模式下eval(); 作用域被改变 12345// 这样在严格模式下 -&gt; 不报错eval('var a = 1; console.log(a)');// 但如果下面还打印a就报错console.log(a); 运行结果： 在严格模式下eval是有自己独立的作用域的,已经不再是全局的作用域了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js错误信息篇","slug":"js错误信息篇","permalink":"http://cokesprit.top/tags/js%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AF%87/"}]},{"title":"try...catch...","date":"2020-08-28T08:18:55.000Z","path":"/posts/a86aeb16/","text":"当系统自动为我们抛出错误的时候程序就不会继续执行，为了解决这个问题我们在可能会报错的地方使用手动抛出错误的方法 -&gt; try…catch…finally…throw,后面两个可以不写但是try…catch是一定要的。 try: 里面没有错误的时候它是不走catchcatch: 第一大要务就是捕获try里面的错误finally: 不管catch里没有错误都执行throw: 可以通过throw 扔出自定义错误 系统自动为我们抛出错误123console.log('正常执行1');console.log(a);console.log('正常执行2'); 运行结果： 手动抛出错误try…catch…finally…throw 1234567891011try{ console.log('正常执行1'); console.log(a); console.log('正常执行2');}catch(e){ console.log(e.name); // 错误类型 console.log(e.message); //错误的具体信息}finally{ console.log('正常执行3');}console.log('正常执行4'); 运行结果： 123456789101112131415161718192021var jsonStr = '';try{ if(jsonStr == ''){ // 抛出错误 throw 'JSON字符串为空'; } // 上面抛出错误了所以下面这里并没有执行 console.log(\"我要执行了!!!\"); var json = JSON.parse(jsonStr); console.log(json);}catch(e){ console.log(e); // 换方案执行 var errorTip = { name:'数据传输失败', errorCode:'10010' } console.log(errorTip);} 运行结果： 补充try … catch 一般用在比较大型的web程序插件里面比较多，一般开发的时候用的比较少。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js错误信息篇","slug":"js错误信息篇","permalink":"http://cokesprit.top/tags/js%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AF%87/"}]},{"title":"JS错误类型","date":"2020-08-28T01:44:10.000Z","path":"/posts/e24d4eb8/","text":"JavaScript有六种错误类型，每一种类型都对应着一种构造函数,这些构造函数都可以通过实例化去定义错误类型。除此之外还有一个总的错误类型 Error。下面分别介绍这六种错误类型。 SyntaxErrorSyntaxError -&gt; 语法错误，有以下几种情况： 变量名不规范1var 1ab = 1; 运行结果： 关键字赋值1function = 1; 运行结果： 基本语法错误1var a = 1: 运行结果： ReferenceErrorReferenceError -&gt; 引用错误 -&gt; 以下都是报引用错误 变量或者函数未声明12test();console.log(a); 运行结果： 给无法被赋值的对象赋值的时候1var a = 1 = 2; 运行结果： RangeErrorRangeError -&gt; 范围错误 -&gt; 以下都是报引范围错误 数组长度赋值为负数123var arr = [1,2,3];arr.length = -1;console.log(arr); 运行结果： 对象方法参数超出可行范围123var num = new Number(66.66);// toFixed 保留小数点几位console.log(num.toFixed(-1)); // 如果为 -1就会报错 运行结果： TypeErrorTypeError -&gt; 类型错误 -&gt; 以下都是报引类型错误 调用不存在的方法1234// 如果写 test(); -&gt; ReferenceError -&gt; 引用错误 // 但 如果写 123(); 报类型错误123(); 运行结果： 123var obj = {};obj.say(); // obj.say; // 这样就不会有错误 运行结果： 没有括号的时候不会报错,证明如果没有这个括号的时候JavaScript会认为这是一个属性只是没有赋值。加了括号以后属性执行了,但是属性不能像函数那样执行,所以报 TypeError -&gt; 类型错误。 实例化原始值1234// new 后面必须是一个构造器var a = new 'String';// var b = new 123; //还是会报类型错误 运行结果： URIErrorURIError -&gt; 编码错误URI介绍：URI：UNIFORM RESOURCE IDENTIFIER 统一的资源标识符URL：UNIFORM RESOURCE LOCATOR 统一资源定位符URN：UNIFORM RESOURCE NAME 统一资源名称 URL和URN是URI的子集 URL：有传输协议、有域名、或者有资源空间例如：http://www.baidu.com/new#todayftp://www.baidu.com/ftp#developer URN：www.baidu.com/ftp#developer -&gt; 唯一的IDhrfe=”tel:13900000”href=”mailto:2665281140@qq.com“ 1234567891011var myUrl = \"http://www.baidu.cin?name=可乐\"; // encodeURI 把URI里面的中文转化为中文字符编码var newUrl = encodeURI(myUrl);console.log(newUrl) // decodeURI将中文编码转化成中文var newNewUrl = decodeURI(newUrl); console.log(newNewUrl); // 如果decodeURI 里面的中文编码乱填的haul就会报错var str = decodeURI('%fdsd'); 运行结果： EvalErrorEvalError -&gt; 全局错误 eval函数执行错误现在呢，这个已经不那么容易报错了。eval();最大的功能是可以在括号写JavaScript程序然后执行还有就是把json对象转化成课循环的对象。不过现在已经很少使用了，es6已经完全摒弃了。 12eval('var a = 1;console.log(a)');console.log(a); 运行结果： 把json对象转化成可循环的对象 123456789101112131415161718var jsonDate = '['+ '{'+ '\"name\": \"abc\"'+ '},'+ '{'+ '\"name\": \"bc\"'+ '},'+ '{'+ '\"name\": \"c\"'+ '},'+']';var data = eval('(' + jsonDate +')');console.log(data);for(var i in data){ var item = data[i]; console.log(item.name);} 运行结果： 为什么不推荐使用 eval?1.实际上es3就不建议是用了es5.0也不建议使用，es6已经完全摒弃了2.语法规范不好3.不好调试4.性能问题5.些许的安全性问题6.可读性差 总结JavaScript的错误类型一共有六种：SyntaxError -&gt; 语法错误ReferenceError -&gt; 引用错误RangeError -&gt; 范围错误TypeError -&gt; 类型错误URIError - 编码错误（比较少见）EvalError -&gt; 编码错误 （很少见） 这六种错误类型都可以人为的抛出通过 new来： 1234567891011121314151617181920var Syerror = new SyntaxError('语法错误');console.log(Syerror);var Reerror = new SyntaxError('引用错误');console.log(Reerror);var Raerror = new SyntaxError('范围错误');console.log(Raerror);var Tyerror = new SyntaxError('类型错误');console.log(Tyerror);var URerror = new SyntaxError('编码错误');console.log(URerror);var Everror = new SyntaxError('编码错误');console.log(Everror);var srror = new Error(\"总的Error\"); // 总的Errorconsole.log(srror); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js错误信息篇","slug":"js错误信息篇","permalink":"http://cokesprit.top/tags/js%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AF%87/"}]},{"title":"字符串去重","date":"2020-08-26T11:42:53.000Z","path":"/posts/dc5c6a5/","text":"字符串去重思路思路和数组的一样的,不过字符串去重相对来说简单一点; 12345678910111213141516171819var str = \"aaa1111222333ddewdd6\";// 方法挂载在String.prototype上String.prototype.unique = function(){ var temp = {}, newStr = ''; for(var i = 0; i &lt; this.length; i ++){ if(!temp.hasOwnProperty(this[i])){ temp[this[i]] = this[i]; //字符串拼接对象也可以 newStr += this[i]; } } return newStr;}console.log(str.unique()); 运行结果： 注意：字符串去重的时候方法挂载在String.prototype上。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://cokesprit.top/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"数组去重","date":"2020-08-26T11:12:22.000Z","path":"/posts/908d091d/","text":"123456789101112131415161718192021222324252627282930// 在JavaScript中属性是字符串只是它可以把字符串变成变量类型 // obj = { // \"0\": 1, // \"1\": 2, // \"2\": 3, // \"3\": 4, // \"4\": 5 // }var arr = [0,0,1,1,2,2,3,3,4,'d'];Array.prototype.unique = function(){ var temp = {}, newArr = []; for(var i = 0; i &lt; this.length; i++){ // 如果不存在则为false,然后取反就为true if(!temp.hasOwnProperty(this[i])){ // 把它添加到对象里面去 temp[this[i]] = this[i]; // 添加到一个新的数组 newArr.push(this[i]); } } // 返回到外界 return newArr;}console.log(arr.unique()); 运行结果: 实现思路：使用for和if还有对象的hasOwnProperty来循环判断添加到个空对象里面，同时添加到一个新的数组里面。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"类数组","date":"2020-08-26T04:01:27.000Z","path":"/posts/5b0dde5/","text":"类数组并不是真正意义上的数组它是类似于数组的对象！！！类数组一定要有以下这几种形式：第一、一定要有数组形式下标对应的值;第二、一定要有length属性;第三、要挂载有数组原型上的方法例如:Array.prototype.push 或者 Array.prototype.splice; 注意：类数组的原型是object真正的数组原型是Array接下来举例子说明： arguments类数组arguments 最典型的的类数组,我们来打印一下它 1234function test(){ console.log(arguments);}test(1,2,3,4,5,6); 运行结果： 写一个类数组按照上面的几种形式写一个完整的类数组 12345678910111213141516171819var obj = { '0':'1', '1':'2', '2':'3', '3':'4', '4':'5', '5':'6', 'length':6, // 也可以将它们挂载到对象的原型上 'push': Array.prototype.push, 'splice': Array.prototype.splice}// 也可以挂载到原型上去// Object.prototype.push = Array.prototype.push;// Object.prototype.splice = Array.prototype.splice;obj.push(\"7\");console.log(obj); 运行结果： 思考push方法是怎么做到的？ 为什么它能在类数组里面起作用呢？ 12345678// push原理在类数组的原理Array.prototype.push = function(elem){ // 真正的写法 谁用this就指向谁 this[this.length] = elem; this.length ++;} 阿里题目下面的打印结果是怎么样的? 1234567891011var obj = { '2':3, '3':4, 'length':2, 'splice': Array.prototype.splice, 'push': Array.prototype.push}obj.push(1);obj.push(2);console.log(obj); 运行结果： 结果为两个空，一个 1 ，一个 2,length长度变成了 4。它是怎么来的呢？ 123456789101112131415// 根据push的原理一步一步的剖析 Array.prototype.push = function(){ this[this.length] = elem; this.length ++; // 最开始length长度为 2 // 第一次push // obj[2] = 1; // obj.length ++; //obj.length变成 3 // 第二次push // obj[3] = 2; // obj.length ++; // obj.length 变成4 } 执行完两次length变成了4，之前的 0 和 1项并没有发生改变而3 和 4 被 1 和 2替换掉了。 补充讲一讲为什么会打印 empty？这是数组的一个特性，可以有空的项,类数组也同样具备这样的特性。 123// 之前讲过的稀松数组var arr = [,,5,6];console.log(arr); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组深入篇","date":"2020-08-24T12:27:16.000Z","path":"/posts/3061e2e2/","text":"数组的深入篇有五个方法分别是concat、slice、toString、join和split。这五个数组方法都不会修改原数组，下面逐个进行讲解。 concat数组concat方法拼接数组,返回拼接后的数组。 1234var arr = ['c','d'];var arr1 = ['a','b'];var arr2 = arr1.concat(arr);console.log(arr2); 运行结果: slice数组slice方法截取数组,并返回截取的部分语法：slice(起始下标包含，结束下标不包含)如果不写参数那就是返回整个数组(数组克隆)如果只写一个参数,就从这个位置截取到最后 1234567891011121314151617181920var arr = ['a','b','c','d','e'];var arr0 = arr.slice();console.log(arr0)console.log(\"\"); var arr1 = arr.slice(1);console.log(arr1)console.log(\"\"); var arr2 = arr.slice(1,4); // b c dconsole.log(arr2)console.log(\"\"); var arr3 = arr.slice(-3,4); // c dconsole.log(arr3)console.log(\"\"); var arr4 = arr.slice(1,-1); // b c dconsole.log(arr4); 运行结果: toString数组toString方法将数组转化成字符串每个元素之间用逗号隔开 1234var arr = ['a','b','c','d'];var arr1 = [1,2,3,4];console.log(arr.toString());console.log(arr1.toString()); 运行结果: join和splitjoin 和 split 是一组!!!! join把数组中的所有元素放入一个字符串。有一个参数该参数通过指定分隔符进行分隔。如果join里面不填写参数那么它和toString方法是一样的。 1234567891011121314var arr = ['a','b','c','d'];// 不填写参数时console.log(\"join不填写参数时：\");var str1 = arr.join();var str2 = arr.toString();console.log(str1+\" \"+str2);console.log(\" \");// 填写参数时console.log(\"join填写参数时：\");var str3 = arr.join(\"-\")console.log(str3); 运行结果: splitsplit(‘分隔符’,’截取位数’)将字符串按照分隔符转换成数组,二个参数为截取的位数可以不写。如果把空字符串 (“”) 用作 参数那么每个字符之间都会被分割。join 和 split 是一组!!! 123456789101112131415161718192021222324var arr = ['a','b','c','d'];// 使用join 变成字符串var arr1 = arr.join();console.log(arr1); // a,b,c,dconsole.log(\" \");// 传入\"\" 的时候var arr2 = arr1.split(\"\"); // [\"a\", \",\", \"b\", \",\", \"c\", \",\", \"d\"]console.log(arr2);console.log(\" \");var arr3 = arr1.split(\",\"); // [\"a\", \"b\", \"c\", \"d\"]console.log(arr3);console.log(\" \");// 传入+ 的时候var arr4 = arr1.split(\"+\");console.log(arr4); // [\"a,b,c,d\"]console.log(\" \");// 有第二个参数时var arr5 = arr1.split(\",\",3);console.log(arr5); // [\"a\", \"b\", \"c\"] 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组排序sort方法","date":"2020-08-23T13:25:47.000Z","path":"/posts/cc10395e/","text":"sort方法按照ASCII来对数组进行排序,返回排序以后的数组,默认按升序排序。当数值有参数传进去的时候只接受函数且这个函数要满足以下两个规则:1.函数里面必须包含两个参数a，b2.必须要有返回值：负值，a就排在前面正值，b就排在前面0 ，保持不动 这两个规则是重中之重,只要掌握了这两个规则啥都不是问题 例子一1234567891011var arr = [27,49,5,7,2];arr.sort(function(a,b){ if(a &gt; b){ return 1; }else{ return -1; } // 简写 // return a - b;});console.log(arr); 例子二降序1234567891011var arr = [27,49,5,7,2,100];arr.sort(function(a,b){ if(a &lt; b ){ return 1; }else{ return -1; } // 简写 // return b - a;});console.log(arr); 运行结果： 笔试 / 面试随机排序1234567891011121314var arr = [1,2,3,4,5,6];arr.sort(function(a,b){ var rand = Math.random(); if(rand &gt; 0.5){ return 1; }else{ return -1; } // 简写 return Math.random() - 0.5;});console.log(arr); 运行结果： 对象排序 根据年龄12345678910111213141516171819202122232425262728293031var arr = [ { name:'张三', age: 18 }, { name:'李四', age: 12 }, { name:'王五', age: 8 }, { name:'赵六', age: 28 },];arr.sort(function(a,b){ if(a.age &gt; b.age){ return 1; }else{ return -1; } // 简写 // return a.age - b.age;});console.log(arr); 运行结果： 字符串排序对比字符串的长度 12345var arr = ['12346','5','1613','54'];arr.sort(function(a,b){ return a.length - b.length;});console.log(arr); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的splice方法","date":"2020-08-22T10:03:23.000Z","path":"/posts/32269d8b/","text":"splice方法可以实现数组的插入删除修改的功能,有三个参数。返回值是以一个数组的形式返回删除的数组。splice(开始项的下标(包含),剪切长度,剪切长度以后最后以为开始添加数据); 剪切长度可以是0和负数。 示例一12345var arr = [1, 2, 3, 4];// 在下标为 1 的地方 删除2位 插入3位arr.splice(1,2,'a','b','c')console.log(arr); 运行结果： 示例二123456// 在 c 和 e 之间添加 dvar arr = ['a', 'b', 'c', 'e'];// 在下标为3 的地方 删除0位 插入一位arr.splice(3, 0, 'd');console.log(arr); 运行结果: 笔试经常考12345var arr = ['a', 'b', 'c', 'e'];arr.splice(-1, 0, 'd'); // -1 即e 所在的位置console.log(arr); // 只要往后数就是 -1 开始 &lt;--- // 只要往前开始就是从 0 开始 ---&gt; 运行结果: splice是如何找到相应的下标的splice 当下标为负数的时候是如何找到相应的下标的它的原理是什么? 12345678910111213141516171819// 传入数组和下标function splice(arr,index){ // 常规写法 // 如果index下标大于或等于0 // if(index &gt;= 0){ // index += 0; // }else{ // // 否则就 index = index + arr.length // index += arr.length; // } // 三目运算 return index += index &gt;=0 ? 0 : arr.length;} var arr = ['a', 'b', 'c', 'e']; var str = splice(arr,-1); console.log(str); // 3 console.log(arr[str]); // e 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的reverse方法","date":"2020-08-22T09:52:20.000Z","path":"/posts/fd9290b5/","text":"reverse 数组倒序排列,就是一个倒序的功能而已 123var arr = ['a', 'b', 'c', 'd'];arr.reverse();console.log(arr); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的pop和shift方法","date":"2020-08-22T09:42:31.000Z","path":"/posts/a6d7cc58/","text":"pop 删除数组的最后一位，并把它返会回来shift 删除数组的第一位，并把它返回回来 1234567891011// popvar arr1 = [1,2,3,4];var str1 = arr1.pop(); // 注意pop是没有参数的!!! 它执行一次删除一个console.log(str1,arr1);// shiftvar arr2 = [5,6,7,8]; // 注意shift也是没有参数的!!! 它执行一次删除一个var str2 = arr2.shift();console.log(str2,arr2); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的push和unshift方法","date":"2020-08-22T09:15:29.000Z","path":"/posts/f5194d63/","text":"push 尾部添加，返回值为执行了方法以后数组的长度unshift 头部添加，返回值为执行了方法以后数组的长度 push方法的实现123456789101112var arr = [1,2,3]; // 尾部添加：获取实参列表和现最后坐标Array.prototype.myPush = function(){ for(var i = 0; i &lt; arguments.length; i++){ this[this.length] = arguments[i]; } return this.length; // 返回添加后的数组长度}console.log(arr.myPush(\"a\",\"b\",\"c\"));console.log(arr); 运行结果: unshift方法的实现第一种123456789101112Array.prototype.myUnshfit = function(){ var pos = 0; for(var i = 0; i &lt; arguments.length;i++){ this.splice(pos,0,arguments[i]); pos++; } return this.length;}var arr = ['d','e','f'];var str =arr.myUnshfit('a','b','c');console.log(arr,str); 运行结果: 第二种使用数组concat方法和使用Array.prototype.slice.call 将argument类数组转化成数组 123456789Array.prototype.myUnshift = function(){ // 将类数组转化成数组 Arr = Array.prototype.slice.call(arguments) var newArr = Arr.concat(this); return newArr;}var arr = ['c','d','e'];var newArr = arr.myUnshift('a','b');console.log(newArr); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"数组的声明和数组的原理","date":"2020-08-22T08:32:04.000Z","path":"/posts/75ee3634/","text":"三种声明数组的方式12345678// 推荐var arr1 = []; // 字面量// 不推荐var arr2 = new Array(); // 通过系统内置的Array 构造函数声明// 不使用var arr3 = Array(); // 可以省略new 数组的原型这三种声明数组的原型是？ 123456789var arr1 = []; var arr2 = new Array();var arr3 = Array(); console.log(arr1.__proto__);console.log(arr2.__proto__);console.log(arr3.__proto__); 运行结果: 总结：所有数组都继承与Array.prototype 数组到底是什么12345678910111213141516171819202122232425// 模仿数组var arr = [1, 2, 3, 4, 5]; // 0 1 2 3 4 // 数组的下标是从零开始的 // index 数组元素的下标(索引值)// 对象var obj = { 0: 1, 1: 2, 2: 3, 3: 4, 4: 5}console.log(arr[2]);console.log(obj[2]);// 结果是一样的，实际上数组的底层机制在JavaScript就是继承对象而来的 // var obj1 = { // name:'a' // } // 数组就是利用了对象的这种机制,而形成JavaScript中的数组,以及对数组元素的访问 // obj1.name -&gt; obj1['name'] 系统机制 运行结果: 总结： 在JavaScript中数组就是对象的另一种形式，虽然写法不同但是它们的底层机制和访问机制是一样的。 稀松数组1234var arr = [,1,2,,3,4,]; // 稀松数组console.log(arr.length);// var arr1 = new Array(,1,2,,3,4); // 这种是不行的 因为这传的是参数不能为空 运行结果: 总结： 数组不一定每一位都有值但是如果最后一位没有值就等于没有最后一位 注意12345678910111213141516var arr = [1,2,3,4,5,6];console.log(arr[6]); // undefined// 为什么打印undefined？// 因为var obj = { 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6}// 数组和对象的底层机制是一样的。没有那个相对于的属性名所以undefined console.log(obj[10]); // undefined 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"看似牛掰的对象拷贝","date":"2020-08-21T01:30:01.000Z","path":"/posts/c8cf727d/","text":"对象拷贝分为浅拷贝和深拷贝也叫做克隆,拷贝对象的时候总会设计到引用值的问题，声明了一个新对象赋值了原来已有的对象,这个时候它们是指向同一个地址的。如果新对象变老对象也会变,老对象变新对象也会跟着变，这就造成了拷贝对象的一个困惑不仅仅是对象数组也是一样的。例如下面的例子: 12345678910var person1 = { name:'张三', age:18}var person2 = person1;person2.name = '李四';person2.sex = 'male';console.log(person1,person2); 运行结果: 知道问题之后我们接下来就来解决它 浅拷贝对象的拷贝其实就是对引用值的拷贝/复制/克隆,最好的方法就是循环的添加到另一对象。 12345678910111213141516171819202122232425262728293031 Object.prototype.num = 1; var person1 = { name:'张三', age: 18, sex: 'male', son:{ fitst:'Jenney', second:'Lucy', third:'Jone' } } // 这就是浅拷贝的方法使用 for in 来实现function clone(origin,target){ var target = target || {} for(var key in origin){ //hasOwsProperty 如果对象具有指定名称的属性,则返回true，否则false。 if(origin.hasOwnProperty(key)){ //剔除原型上的属性 target[key] = origin[key] } } return target;}var person2 = clone(person1);person2.name = '李沐子';person2.sex = 'female';person2.son.forth = 'Juck';console.log(person1);console.log(\" \");console.log(person2); 运行结果: 从运行结果看name和sex更改成功且不会影响到老对象但当增加son对象时,老对象还是会受到影响。总结: 浅拷贝处理不了对象里面的引用值 深拷贝使用Object.prototype.toString.call 和 typeof进行深拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 // 深拷贝 function deepClone(origin,target){ var target = target || {}, toStr = Object.prototype.toString, arrType = '[object Array]'; for(var key in origin){ // 判断key到底是不是origin本身的或是原型上的属性 if(origin.hasOwnProperty(key)){ // 判断是不是引用值，并且不等于 null if(typeof(origin[key]) === 'object' &amp;&amp; origin[key] !== null){ // 判断是对象还是数组 if(toStr.call(origin[key]) === arrType){ target[key] = []; }else{ target[key] = {}; } // 然后递归 deepClone(origin[key],target[key]); }else{ // 如果是原始值就直接赋值 target[key] = origin[key]; } } } return target; // 把新的target 返回出去 } Object.prototype.num = 1; var person1 = { name:'张三', age: 18, sex: 'male', son:{ fitst:'Jenney', second:'Lucy', third:'Jone' }, car:['Benz','Ferrari'] }var person2 = deepClone(person1);person2.name = '李四';person2.sex = 'female';person2.son.forth = 'Juck';person2.car.push('Mazda');console.log(person1);console.log(\" \");console.log(person2); 运行结果: 实现过程： 使用for循环遍历剔除prototype上的自定义的属性/方法 在循环里面判断哪个是引用值和原始值并且不能是null 不是引用值就直接赋值，如果是引用值再使用Object.prototype.toString.call判断是对象或是数组。 如果是对象则target赋值一个空对象，否则就赋值一个空数组 然后使用递归 deepClone(origin[key],target[key]) 最后把新的 target 返回出去 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"http://cokesprit.top/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"利用原型深度封装typeof方法","date":"2020-08-19T10:02:10.000Z","path":"/posts/1dce70fc/","text":"在开发中有时候我们需要判断属性的具体类型,而系统给的typeof不足以去判断属性的具体类型，我们需要利用原型来对typeof进行深度封装。typeof返回值有：number string boolean object function undefined 以字符串的形式返回。 123456789101112131415161718192021222324252627282930313233function myTypeof(){ var type = typeof(val); // 使用typeof判断val的类型 var toStr = Object.prototype.toString; // 存入结果集 var res = { '[object Array]':'array', '[object Object]':'object', '[object Number]':'object number', '[object String]':'object string', '[object Boolean]':'object boolean', } if(val === null){ return 'null'; }else if(type === 'object'){ // 返回引用值的具体类型 var ret = toStr.call(val); return res[ret]; }else{ return type; }} console.log(myTypeof(1)); console.log(myTypeof('s')); console.log(myTypeof(true)); console.log(myTypeof({})); console.log(myTypeof([])); console.log(myTypeof(new Number(1))); console.log(myTypeof(new String(1))); console.log(myTypeof(new Boolean(1))); console.log(myTypeof(function(){})); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"烧脑的this指向问题","date":"2020-08-19T03:11:39.000Z","path":"/posts/2198d04d/","text":"对于很多的初学者this指向确实是一个让人比较头痛的问题，一般this指向分为几种情况:1.在全局的时候2.普通函数里面3.构造函数的this指向4.apply/call下面我们就来举例说明以上情况的的this指向问题 在全局的时候123var d = 3;console.log(this.d); console.log(window.d); 运行结果： 从上面的运行结果可以看出二者输出的结果是相同的这样说明全局下的this -&gt; window 预编译函数(普通函数)12345678function test(b){ this.d = 8; var a = 2;}test(123);console.log(this.d);console.log(window.d); 运行结果： 查看运行结果发现它们的结果是一样的这就说明,在普通函数的内部只要没有实例化这个函数的this是默认指向window的。 构造函数内部1234567891011121314151617181920 function Test(){ this.name = 'niming'; } var test = new Test(); // 预编译期的过程 // GO = { // Test:function test(){...} // test:{} // } // AO = { // // 前面我们说了普通函数没new之前 this -&gt; window // this: window, // 当 new 的时候之前的 this 被覆盖 // this:{ // name:'123', // __proto__:Test.prototype // } // } 当预编译的时候 this -&gt; window,当 new 之前GO就已经把保存了 Test:function test(){…} 然后再保存 test:{},但是 new（AO开始） 的时候 Test构造函数内部隐式的 var 了一个 1234this = { name:'123', \\_\\_proto\\_\\_:Test.prototype} 并且覆盖了之前指向window的this,最后系统隐式的把这个新的this返回了出去被全局下的test接收到,从这里我没可以总结出来构造函数的this指向实例化对象 call/apply12345678910111213141516// call/apply的作用是this指向 function Person(name,age){ this.name = name; this.age = age; // Person使用了apply, 当Programmer实例化之后Personn内部属性变成 // p.name = \"张三\"; // p.age = 18; } function Programmer(name,age){ Person.apply(this,[name,age]); this.work = 'Programming'; } var p = new Programmer('张三',18); console.log(p) 运行结果: 因为Person使用了apply把自身构造函数内部的指this指向变成Programmer的实例化对象 p，所以打印p的时候 p 也有Person构造函数的属性。 总结：全局this -&gt; window预编译函数（普通函数）this -&gt; window构造函数的this指向实例化对象apply/call改变this指向 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"英语语法上","date":"2020-08-18T13:41:25.000Z","path":"/posts/9416cc31/","text":"课程设置 #### 一、简单句 #### 二、并列句 #### 三、从句 ##### 名词性从句 ##### 定语和定语从句 ##### 状语和状语从句 一、简单句what is 简单句？英语的句子必须具备主谓结构,并且主语一定是谓语动作的发出者如果有宾语的话宾语一定是谓语动作的承受者。 试译：我的英语说的很好;主：我谓：说宾：英语I speak English every well. 试译：我家住在玉林谓：住主：我I live in Yuli 试译：我要去剪头主：一个理发师谓：剪宾：我的头发 A barber will cut my hair.解析:这句话中我不能充当主语，因为动作的发出者不是我，动作的发出者是理发师所以理发师是主语 简单句的分类1.主谓2.主谓宾3.主谓表4.主谓双宾5.主谓宾宾补 主谓结构He died. We laugh(ed). 主谓宾谓语：实意动词 主系表谓语：系动词1.be2.感官动词：look smell sound taste feel;3.变化: become get4.保持: keep stay remain 上面所出现的都是主谓表结构，以外的都是主谓宾结构。 主谓双宾I bought him a dog说明：双宾就是两个宾语你是你我是我 主谓双宾和主谓宾宾补的区别就在于：需要在两 主谓宾宾补说明：宾补就是后面的那个单词对前面的那个单词的补充说明 主谓双宾和主谓宾宾补的区别:只需要在两个宾语之间加一个be动词，如果读起来意思是不对的就是主谓双宾，如果读起来意思是对的就是主谓宾宾补。 练习:We elect him our monitor.解题：在 him 和 our monitor之间加上be动词 变成 –&gt; We elect him is our monitor. 意思是对的所以是主谓宾宾补 句子的成分**！！！很重要谓语：(1)谓语的成分：有时态的实义动词或系动词充当谓语。 (2)动词能不能多？谓语只能是动词；动词只能做谓语,所以我们需要把一句话当中,所有不做谓语的动词全部都要变成不是动词。怎么把动词变成不是动词呢?①在动词后面加-&gt; ving -&gt; : ving表示主动②在动词后面加-&gt; ved -&gt; : ved被动③在动词前面加-&gt;to do -&gt; : to do 表示目的它们三个有个共同名字:小名叫做不是动词,大名叫做非谓语动词。 试译：他拍了拍我的肩膀,一句话都没说就离开了。He beating my shoulder,saying nothing departed当一句话有多个动词的时候,谁的意思最重要就选谁做谓语!!! 爱我就是 抱抱我Loving me is hugging (embracing) me. 我爱你,你爱我I loveing you,you love me. –&gt; 独立主格 例子：Beating you is my faultI enjoy watching TVMy dream is becomeing a teacherYour mother must be very beautiful; 二、并列句三、从句名词性从句定语和定语从句状语和状语从句 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"英语","slug":"英语","permalink":"http://cokesprit.top/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"Object.prototype.toString","date":"2020-08-18T10:10:59.000Z","path":"/posts/dc56b3a9/","text":"1234567// 同时都是toString()但打印出来的东西是不一样 console.log(Object.prototype.toString.call(1)); console.log(Object.prototype.toString.call(true)); console.log(Object.prototype.toString.call([1, 2, 3])); console.log(Object.prototype.toString.call({name:'张三'})); console.log(Object.prototype.toString.call(null)); console.log(Number.prototype.toString.call(1)); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://cokesprit.top/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"判断是否是数组的三种方法","date":"2020-08-18T09:13:23.000Z","path":"/posts/7a59e1cc/","text":"在开发中后端传过来的数据有可能是 null、对象、Array,有时候我们需要判断传回来是不是数组。 第一种使用 constructor 12var a = [];console.log(a.constructor); //ƒ Array() { [native code] } 运行结果: 第二种使用 instanceof 判断该对象是否是该构造函数构造出来的,是返回ture，否则返回false 1234var str = \"Hello word\"; var a = [];console.log(a instanceof Array);console.log(str instanceof Array); 运行结果: 第三种使用call和Object原型下的toString方法来进行判断。推荐使用这种！！！ 12345678910111213141516171819// 把 Object原型下的toString方法赋给 strvar str = Object.prototype.toString;var trueTip = '[object Array]';// 然后利用call指向aif(str.call(a) === trueTip){ console.log('是数组');}else{ console.log('不是数组');}// 执行分析 // Object.prototype = { // toString:function(){ // // 没call 之前 // this.toString(); // // call 以后更改 this 指向 -&gt; a // a.toString(); // } // } 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js/数组","slug":"js-数组","permalink":"http://cokesprit.top/tags/js-%E6%95%B0%E7%BB%84/"}]},{"title":"企业模块化开发","date":"2020-08-18T08:23:21.000Z","path":"/posts/adbaaf4/","text":"在开发的时候往往需要写很多功能模块,为了更好的协作开发需要采用模块化开发的方式,把这些功能分一个一个的分开来写最后汇总到一个大模块里。 模块化开发12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 第三步window.onload = function(){ init();}// 第二步function init(){ initCompute(); initFunctions();}// 第一步 // 功能一initCompute = (function(){ var a = 3, b = 4; function add(){ console.log(a + b); } function minus(){ console.log(a - b); } function mul(){ console.log(a * b); } function div(){ console.log(a / b); } return function(){ add(); minus(); mul(); div(); }})();// 第一步 // 功能二 var initFunctions = (function(){})(); 把功能全部封装到各自的自启动函数里面，然后分别赋给initCompute 和 initFunctions，再把他们放到一个总的init里面,最后再放到window.onload里面执行。 模块化练习使用模块化开发的实现两个功能:1.求n的斐波拉契数列2.输入一个数n求有打印那些可以被3获被5获被7获整除的数 123456789101112131415161718192021222324252627282930313233343536373839window.onload = function(){ init();}// 把每个模块放到init里面function init(){ console.log(initFb(10); console.log(initDiv(100);}// 斐波拉契数列var initFb = (function(){ function fb(n){ if(n &lt;= 0){ return 0; } if(n &lt;= 2){ return 1; } return fb(n-1) + fb(n-2); } return fb;})();// 被3或被5或被7或整除var initDiv = (function(){ function div(n){ var arr = []; for(var i = 0; i &lt;= n; i++){ if(i % 3 === 0 || i % 5 === 0 || i % 7 === 0){ arr.push(i); } } return arr; } return div; })(); 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型继承之圣杯模式","date":"2020-08-17T11:27:04.000Z","path":"/posts/98829262/","text":"之前的那几种方案都不太尽人意,在解决继承,有专门的企业即解决方案圣杯模式。 圣杯模式12345678910111213141516171819202122232425262728293031function Teacher(){ this.name = 'Mr. Li'; this.tSkill = 'JAVA';}Teacher.prototype = { pSkill: 'JS/JQ';}function Student(){ this.name = 'Mr. Wang';}// 创建一个缓冲区介于 Teacher 和 Student之间function Buffer(){}Buffer.prototype = Teacher.prototype;var buffer = new Buffer();// Buffer 实例化出来之后没有属性和方法,// 但是它有Teacher.prototype// 然后把实例化对象buffer赋给Student.prototypeStudent.prototype = buffer;// 这样Student实例化出来的对象就能访问Buffer.prototype// 也能访问到Teacher.prototype// 这就是圣杯模式完美解决了继承和隔离的问题。Student.prototype.age = 18;var s = new Student();console.log(s); 运行结果： 圣杯模式封装为了方便使用我们把它封装起来,这样我们需要的时候直接调用就行了 123456789101112// 圣杯模式之封装var inherit = (function(){ var Buffer = function(){} return function(Target,Origin){ Buffer.prototype = Origin.prototype; Target.prototype = new Buffer(); // 为了还原构造器,把Target构造器重新指向 Student Target.prototype.constructor = Target; // 继承源 Target.prototype.super_class = Origin; }})(); 企业级的解决方案 -&gt; 这是雅虎当年在 YUI3 里面封装的一个方法,虽然 YUI3 已经不在了但是这个方法被留存了下来。 例子写一个程序员的构造函数，然后再写各写一个前端程序员和后端程序员的构造函数,并且这两个构造函数继承程序员这个构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 实现继承的方法var inherit = (function(){ var Buffer = function(){}; return function(Target,Origin){ Buffer.prototype = Origin.prototype; Target.prototype = new Buffer(); Target.prototype.constructor = Target; Target.prototype.super_class = Origin; }})(); // 采用模块化开发方式var initProgrammer = (function(){ var Programmer = function(){} // 把一些很少更改的属性和方法写到原型上 Programmer.prototype = { name:'程序员', tool:'计算机', work:'编写应用程序', duration:'10个小时', say:function(){ console.log('我是一名' + this.myName + this.name + \"我的工作用到\" + this.tool + this.work + \",我每天工作\" + this.duration + \" ，我的工作需要用到：\" + this.lang.toString() + \"。\"); } } function FrondEnd(){} // 前端工程师 function BackEnd(){} // 后端工程师 inherit(FrondEnd,Programmer); // 使用 inherit 实现继承 inherit(BackEnd,Programmer); FrondEnd.prototype.lang = ['HTML','CSS','JavaScript']; FrondEnd.prototype.myName = '前端'; BackEnd.prototype.lang = ['Node','Java','SQL']; BackEnd.prototype.myName = '后端'; // 把它们写在一个对象里面返回出去 return { FrondEnd:FrondEnd, BackEnd:BackEnd }})();// 实例化对象 var frondEnd = new initProgrammer.FrondEnd(); var backEnd = new initProgrammer.BackEnd(); frondEnd.say(); backEnd.say(); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"公共原型继承","date":"2020-08-17T10:15:36.000Z","path":"/posts/8f490e5b/","text":"使用call/apply这种方法也不尽人意,我在想我这样写行不行 123456789101112131415161718192021function Teacher(){ this.name ='Mr. Li'; this.tSkill = 'JAVA';}Teacher.prototype = { pSkill:'JS/JQ';}var t = new Teacher();console.log(t);function Student(){ this.name = 'Mr. Wang';} Student.prototype = Teacher.prototype; Student.prototype.age = 18; var s = new Student(); console.log(s); 运行结果: 把 Teacher 的原型赋给 Student 的原型，这样的话 Stduent 下的属性也可以拥有而且还可以拥有 Teacher 原型的下属性,并且没有继承Teahcer下的一些属性我们不需要的属性。 问题：这种方式也有一点不好的就是如果向 Student.prototype 增加属性和方法的时候也会添加的 Teacher.prototype 里面。因为它们两个指向同一个地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"借助call或apply实现继承","date":"2020-08-17T09:50:13.000Z","path":"/posts/18be6742/","text":"上篇使用原型链的方式来继承并不是很科学,像老鼠的名字就没有必要继承。这次我们使用call/apply实现继承。 1234567891011121314151617// call/applyTeacher.prototype.wife = 'Ms. Min';function Teacher(){ this.name = name; this.mSkill = mSkill;}function Student(name,mSkill,age,major){ Teacher.apply(this,[name,mSkill]); this.age = age; this.major = major;}var student = new Student('Mr. Li','JS/JQ/',18,'Computer');console.log(student);console.log(student.wife); // 访问不到Teacher.prototype下的属性 运行结果: 问题：这种方式不太像继承,叫借用更加贴切,而且这种方式访问不到Teacher.prototype,这种方式也不太理想。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型链继承","date":"2020-08-17T09:05:42.000Z","path":"/posts/31601a23/","text":"1234567891011121314151617181920212223242526 Professor.prototype = { name:'Mr. Li', tSkill:'JAVA' } function Professor(){} var professor = new Professor();// ---------------分割线----------------- // 把professor实例对象赋给 Teacher.prototype Teacher.prototype = professor; function Teacher(){ this.name = 'Mr. Mi'; this.mSkill = 'JS/Jq'; } var teacher = new Teacher();// ---------------分割线----------------- // 把 teacher实例对象赋给Student.prototype Student.prototype = teacher; function Student(){ this.name = 'Mr. Xiao'; this.pSkill = 'HTML/CSS'; } var student = new Student(); console.log(student); 运行结果： student 现在这个对象继承了 Teacher 上所有属性和 Teacher 原型上的属性,也继承了 Professor 原型上的属性。 总结：最下面的对象继承了上面原型链上的所有属性，这就是原型链继承。 问题：学生身上是否需要继承Teacher 和 Professor 上所有的属性或者原型上的属性?不需要,所以继承方案还不是特别理想。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"插件化编程开发初探","date":"2020-08-15T08:35:01.000Z","path":"/posts/e0979614/","text":"JS插件的写法1234567891011121314151617// JS 插件的写法 // 立即执行函数 -&gt; 防止变量污染 -&gt; 为了隔离全局作用域 ;(function(){ function Test(){ } // 开发中方法基本上都是写在原型上的 // 很少更改的东西也可以写到原型上 Test.prototype = { } window.Test = Test; // 挂到window上 })(); var test = new Test(); 练习12345678910111213141516171819202122232425262728// 传两个数字实现加减乘除的插件;(function(){ var Compute = function(opt){ } Compute.prototype = { plus:function(a,b){ return a + b; }, minus:function(a,b){ return a - b; }, mul:function(a,b){ return a * b; }, div:function(a,b){ return a / b; } } window.Comput = Compute; })();var comput = new Comput();var res = comput.div(2,2);console.log(res); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"Object.create","date":"2020-08-15T07:25:21.000Z","path":"/posts/3837d091/","text":"Obcet.create():创建对象,提供一个自定义原型的功能,参数是对象或者null。 参数是null时12var s = Objcet.create(null);console.log(s); // {} 运行结果： 总结:Object.create(null);创建的对象是没有原型的。 参数是对象时1234567891011121314151617var test = { num:2, say:function(){ console.log('今天天气真好'); }}function Obj(){}Obj.prototype.num = 1;var obj2 = new Obj();console.log(obj2);// 使用Object.create自定义原型var obj2 = Object.create(test); console.log(obj2);obj2.say(); 运行结果： 总结：Object.create 可以把其他的对象作为原型,形成一个祖先与后代的关系。使用Object.create()实现继承会更优雅一些。 面试/笔试不是所有的对象都继承于Object.prototype:Object.create(null)创建出来的对象没有原型所以不继承于Object.prototype document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型链","date":"2020-08-14T09:15:54.000Z","path":"/posts/bf8cf30/","text":"原型链原型链：沿着__proto__去找原型里的属性,一层一层的去继承原型的属性所形成的链条,我们我做原型链。 12345678910111213141516171819Professor.prototype.tSkill = 'JAVA';function Professor(){}var professor = new Professor();Teacher.prototype = professor;function Teacher(){ this.mSkill = 'JS/JQ';}var teacher = new Teacher();Student.prototype = teacher;function Student(){ this.pSkill = 'HTML/CSS';}var student = new Student();console.log(student); 运行结果: 我没有的属性我到我的原型上找,如果没有就一直往上找,这样就形成了一条链条。 补充所有的对象都有原型,包括原型的本身原型的顶端是Object.prototype!!!原型链上面的增删改只能是它自己本身!!!原型的原型是由系统自带的Object构造出来的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"原型","date":"2020-08-14T01:49:21.000Z","path":"/posts/263f3be4/","text":"原型涉及到构造函数和实例化对象,原型是在构造函数之上的,它也是构造函数的一个属性。 prototype和__proto__prototype:原型构造函数上的一个属性,只不过这个属性是一个对象而已 12345678910111213141516function Handphone(color,brand){ this.color = color; this.brand = brand;}Handphone.prototype.rom = '64';Handphone.prototype.ram = '6G';var hp1 = new Handphone('黑色','小米');console.log(Handphone.prototype); // 打印出来是一个对象// 原型prototype其实是function对象的一个属性// 这个prototype是构造函数构造出来的每一个对象的公共祖先console.log(hp1.rom); // 64// 所有被构造函数构造出来的对象都可以继承原型上的属性和方法 运行结果: constructorprototype原型的一个属性,指向构造函数本身 12345 function Handphone(color,brand,system){ this.color = color; this.brand = brand;}console.log(Handphone.prototype); 运行结果: 既然 constructor 指向的构造函数本身那我们来尝试一下让它指向其他的构造函数看可不可以 1234567891011121314 function Handphone(color,brand){ this.color = color; this.brand = brand;}function Telephone(color,brand,system){ this.color = color; this.brand = brnad; this.system = system;}Handphone.prototype = { // 让constructor指向另一个构造函数 constructor:Telephone}console.log(Handphone.prototype); 运行结果: constructor可以指向其他构造函数 __proto____proto__: 每一个实例化对象的原型容器,它就是装prototype的 123456789101112131415161718Car.prototype = { color:'白色', brand:'benz'}function Car(){ // 当构造函数实例化的时候 // 隐式的进行 // var this = { // __proto__: Car.prototype = { // color:'白色', // brand:'benz' // } // }}var car = new Car();console.log(car.__proto__);console.log(Car.prototype); 运行结果: 补充1.通过实例化对象更改自己的祖先是不行的2.所有被该构造函数构造出的对象都可以继承原型上的属性和方法3.prototype里面的constructor可以修改4.constructor 保存的是实例化之前的东西 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js原型/原型链","slug":"js原型-原型链","permalink":"http://cokesprit.top/tags/js%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"instanceof","date":"2020-08-11T09:12:18.000Z","path":"/posts/instanceof/","text":"instanceof 判断该对象是否是该构造函数构造出来的,是返回true不是返回false。 12345678910111213 function Car(){} var car = new Car(); function Person(){} var p = new Person();console.log(p instanceof Car); // false console.log(car instanceof Car); // true console.log(car instanceof Object); // true console.log([] instanceof Aarry); // true console.log([] instanceof Object); // true console.log({} instanceof Object); // true console.log({} instanceof Array); // false 总结：A对象的原型到底有没有B的原型,有的话就是 true,没有就是false。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面试/笔试","slug":"面试-笔试","permalink":"http://cokesprit.top/tags/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95/"}]},{"title":"in","date":"2020-08-11T08:58:35.000Z","path":"/posts/5fec8e4e/","text":"in 判断属性是否存在对象里。 123456var car = { brand:'Benz', color:'white'} // car对象不存在 displacementconsole.log('displacement' in car); // false in 不排除原型上自定义的属性。 12345678910var car = { brand:'Benz', color:'white'}Car.prototype = { displacement: '3.5'}var car = new Car();console.log('displacement' in car); // true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"hasOwnProperty","date":"2020-08-11T02:02:08.000Z","path":"/posts/hasOwnProperty/","text":"hasOwnProperty()如果对象具有指定名称的属性，则返回turn否则返回false 1234567891011121314151617181920212223242526function Car(){ this.brand = 'farrari'; this.color = 'red'; this.displacement = '6.0';} Car.prototype = { lang:5, width:2.5 } Object.prototype.name = 'Object'; console.log('第一次打印') // 连Car.prototype 和 Object.prototype 上自定义的属性都打印出来了 for(var key in car){ console.log(key + ' : '+car[key]); } var car = new Car(); console.log('使用了hasOwnProperty()方法之后') for(var key in car){ if(car.hasOwnProperty(key)){ console.log(car[key]); } } 运行结果： 总结：hasOwnproperty()主要用来找对象自身的属性,排除原型上自定义的属性 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"http://cokesprit.top/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"对象枚举","date":"2020-08-11T01:39:31.000Z","path":"/posts/1313d393/","text":"其实JavaScript并没有真正意义上的枚举,在 JavaScript 中有遍历就是有枚举。 对象的遍历使用 for…in 1234567891011121314151617// 使用 for...in var car = { brand:'Ferrari', color:'red', displacement:'6.0', lang:'5.5', width:'2.5'}for(var key in car){ // 重点！！！ // console.log(car.key); // 为什么打印 undefined？ // 因为 js 处理的时候是：car.key -&gt; car['key'] -&gt; undefined console.log(key + ' : ' + car[key]);} 运行结果： 数组是特殊的对象它也可以使用for…in来遍历 12345var arr = [1,2,3,4,5,6] ;for(var i in arr){ console.log(arr[i]);} 运行结果： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"http://cokesprit.top/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"包装类","date":"2020-08-10T00:40:22.000Z","path":"/posts/52c58cb2/","text":"原始值没有自己的方法和属性！！！原始类型：Number、String、Boolean、Undefined、Null引用类型：Object、Function、Aarry、Date、RegExp 包装类12345678910111213141516171819var a = 1;a.len = 3;//a.len的时候系统转化成 ↓ // new Number(1).len = 3; new 前面没有东西接收, // 只能 delete 掉,所有打印 undefinedconsole.log(a.len); // undefined// 这时候我们就用到了包装类 // 变成实例化数字对象就可以有自己的属性和方法了var aa = new Number(1);aa.len = 3;console.log(aa.len); // 3// 经过 new Number 包装了之后再参与运算又会返回原始值var d = aa + 1;console.log(d); // 2// 像这种经过包装了之后再返回原始值的有三种 // new Number new String new Boolean 运行结果： 上面我们说了原始值是没有方法和属性的那下面这个又是怎么回事呢？ 1234567891011121314var str = \"abcd\";// 这又是怎么回事呢？console.log(str.length); // 4// 系统帮我做了如下的包装 ↓ new String(str).length; // String 是有length这个属性的,所以可以通过这样的包装来访问到String里面独有的属性 // 其实系统打印的是 console.log(new String(str).length); // 4// 面试如果别人问你字符串有没有 length 属性？ //记住字符串没有 length 属性 中间是经过了一层包装类 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"http://cokesprit.top/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"构造函数实例化的原理","date":"2020-08-06T03:10:47.000Z","path":"/posts/constructor/","text":"下面是构造函数实现实例化的原理,涉及到预编译、AO、GO、对象等知识 构造函数实例化的原理1234567891011121314151617181920212223242526272829303132333435363738 // 构造函数 function Car(color,brand){ // 第一步：系统会保存一个空的this对象 // this = {} // 第二步：系统将属性和方法写到 this 对象里面 // this = { // color:color, // brand:brand // } 和下面的一样 this.color = color; this.brand = brand; // 第三步：系统隐式的在后面加了 return this; 这一步很重要！！！ // return this; } // new 负责把this造出来和把原本指向window的this,转向实例化的对象 var car1 = new Car('黑色','兰博基尼'); console.log(car1.color,car1.brand);// GO 和 AO // GO = { // Car:(function), // car1:{ // color:'黑色', // brand:'兰博基尼' // } // } // AO = { // this:{ // color:color, // brand:brand // } // } 图一 自己实现构造函数的功能既然我们知道 new 仅仅是帮我们把 this 造出来和改变this的指向,那我们是不是可以不用 new 和 不使用 this 实现构造函数的功能? 1234567891011121314151617// 按照上面实例化的原理步骤我们来尝试一下是否可行function Car(color,brand){ // 第一步保存一个空对象 obj var obj = {} // 第二步将属性和方法写到 obj 对象里面 obj.color = color; obj.brand = brand; // 第三步 return obj return obj; }var car = Car('红色','法拉利');console.log(car.color,car.brand); 图二 从图一和图二看出它们两者并没有什么不同,我们是可以自己实现构造函数实例化的功能的。 有趣的如果我们在最后return 的时候改变为其他值呢?最后的结果会发生什么变化? 12345678910111213141516function Car(color,brand){ this.color = color; this.brand = brand; // 逐一尝试 return 不同的结果 return 'abc'; // return 123; // return {}; // return function(){} // return []}var car = new Car('白色','宝马');console.log() 图三 图四 总结:构造函数 return 出来原本是隐式的this,如果我们故意 return 了引用值那么它就是引用值,原始值的话是不受还是this。 引用值:Object、Function、Array、Date、RegExp 原始值: Undefined、Null、Boolean、Number 和 String document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js对象","slug":"js对象","permalink":"http://cokesprit.top/tags/js%E5%AF%B9%E8%B1%A1/"}]},{"title":"window.xxx=xxx 与 return xxx的区别","date":"2020-08-05T02:40:50.000Z","path":"/posts/8b19ee89/","text":"区别: 使用 return 出去后需要把执行函数赋值给一个全局变量,然后再执行这个全局变量的函数 使用 window 直接将函数保存到GO。既把函数保存到 window 上的一个变量,然后再执行 window 上变量所对应的函数。 下面来举例说明 123456789101112 // 使用return xxxvar add = (function (){ var a = 1; function add(){ a++; console.log(a); } return add; // 把内部的add函数返回给全局变量add})();add();add();add(); 运行结果: 123456789101112// 使用window.xxx = xxx(function (){ var a = 1; function add(){ a++; console.log(a); } window.add = add; // 把内部的add函数保存到window.add上})();add();add();add(); 运行结果: 从上面的例子可以看出window.xxx = xxx 和 return xxx 二者是结果是一样,使用window.xxx = xxx 也是可以形成闭包。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"闭包","slug":"闭包","permalink":"http://cokesprit.top/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"闭包基础","date":"2020-08-04T02:30:39.000Z","path":"/posts/3d615767/","text":"闭包的定义：当内部函数被返回到外部并保存时,就一定会形成闭包。 闭包的优点: 避免全全局变量的污染; 私有成员的存在; 希望一个变量长期存储在内存中。 闭包的缺点: 闭包会产生原来的作用域链不释放。 过渡的闭包可能会导致内存泄漏或加载过慢,因为它常驻内存。 闭包的用途:可以用来做数据缓存。 闭包的三个特性: 函数嵌套函数。 函数内部可以引用外部的参数和变量。 参数和变量不会被垃圾回收机制回收。 栗子1234567891011121314function test1(){ function test2(){ var a = 3; console.log(x); } var x = 2; return test2;}var b = 4;var test3 = test1();test3(); // 2// 这就是一个简单闭包 练习面包管理器 123456789101112131415161718192021function breadMgr(num){ var breadNum = arguments[0] || 10; function supply(){ breadNum += 10; console.log(breadNum); } function sale(){ breadNum--; console.log(breadNum); } return [supply,sale];}var breadMgr = breadMgr(60);breadMgr[1](); // 售出breadMgr[1](); // 售出breadMgr[1](); // 售出breadMgr[0](); // 补给 运行结果: 星期天计划管理器 123456789101112131415161718function sunSched(){ var sunSched = ''; var operation = { setSched: function(thing){ sunSched = thing; }, showSched: function(){ console.log(\"My schedule on sunday is \" + sunSched); } } return operation; // 把对象返回出去}var sunSched = sunSched(); //执行返回 operationsunSched.setSched('studying');sunSched.showSched(); 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"闭包","slug":"闭包","permalink":"http://cokesprit.top/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"作用域与作用域链图解","date":"2020-08-03T01:42:56.000Z","path":"/posts/ab6a816/","text":"作用域与作用域链 栗子一123456789function a(){ function b(){ var b = 2; } var a = 1; b();}var c = 3;a(); 图解当a函数被定义时 当a函数被执行时(前一刻) 当b函数被定义时 当b函数被执行时(前一刻) 当b函数被执行结束后 回归b函数被定义时的状态 当a函数被执行结束时 回归a函数被定义时的状态 以上这就是作用域和作用域链的最基本的一个形态 栗子二这个例子比较特殊涉及到闭包,有关闭包的在下一篇更新。 123456789101112function test1(){ function test2(){ var b = 2; console.log(a); } var a = 1; return test2;}var c = 3;var test3 = test1();test3(); 当test1函数被定义时 当test1函数被执行时(前一刻),函数test2被定义 当test1函数被执行结束时 这时test1的AO并没有被销毁只是把线剪断了,test1的AO本该是要被销毁的,但test2已经被返回到外部且死死的抓住test1的AO不放,所有test1的AO不能销毁。注意这里是重头戏,这时候就形成了闭包了！！！ test3执行 这时的 test3 === test2。a是在test1的AO里面的,为什么可以打印出来a? 就像之前讲的test2还死死的攥着test1的AO,当在自己的AO上没有查找到,则想test1的AO查找,实际操作的仍然是test1的AO。 补充 每个函数在定义的时候就已经保存了全局上下文GO。 函数自己的AO产生了,就会把自己AO排在作用域链的最顶端,其他AO和全局GO就会被挤下去。 函数被定义的时候它拿的是它上一级的作用域链。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"http://cokesprit.top/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"作用域之对象的隐式属性[[scope]]","date":"2020-08-02T13:13:15.000Z","path":"/posts/scope/","text":"[[scope]] -&gt; 作用域，它是函数创建时，生成的一个JS内部的隐式属性，这个属性只能由JS引擎来读取的。 [[scope]] [[scope]]它是函数创建时,生成的一个JS内部的隐式属性。 [[scope]]它是存储函数作用域链的 容器,作用域链存储的是AO/GO。 GO:全局执行期上下文AO：函数执行期上下文，当函数执行完成以后，AO是要销毁的,如果再次执行这个函数的时候AO会重新生成而且这个AO是新的AO。也就是说每一次执行会生成一个新的AO，原来老的AO在函数执行完以后它就会被销毁，也就是说AO是一个即时的存储容器;它不是长期保存的，它是根据函数的执行周期来保存。而作用域链其实就是把这些AO/GO形成链式从上到下排列起来,形成一个链式关系,这个链式关系其实就是作用域链。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"http://cokesprit.top/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"搬砖日记","date":"2020-07-27T04:54:14.000Z","path":"/posts/tote-bricks/","text":"前言为什么选择去工地搬砖,而不是去广东进厂?1.我大伯接了一个工程,挺赶的,人手不够。2.去广东的话车费来回要六百块,不划算。3.进厂一天十二个小时感觉有点吃不消,且一天没有多少学习时间。 第一天2020-07-27-14:00整就被家里人叫去工地帮忙。到哪要干的事很简单,只需要把砖,水泥、碎石杂、沙子放到斗车里,然后拉到吊机下面给吊机吊上楼顶。晚上七点钟下班感觉身体有点吃不消,手脚都有点酸;可能是太久没干重体力活的原因,想想过几天适应了可能就好受点。晚上十点钟时就有一股深深的困意袭来,虽然很困,但还是把今天的任务完成。 第二天2020-07-28早上六点四十分起来时感觉全身酸痛,手还有点发抖。今天要上一整天的班,上班时间为上午7:00 - 12:00,下午14:00 - 19:00一共十个小时;相比于进厂的话要好一点,晚上还能有一些时间留给自己。 今天还是重复昨天的工作把砖,水泥、碎石杂、沙子放到斗车里,然后拉到吊机下面给吊机吊上楼顶。对我来说沙子是最难弄的,要把沙子铲到斗车里面去。沙子有点湿再加上我左手腕有暗伤,打篮球的时候伤的时间有两个月了,我以为好了;谁知道当把沙子铲到铲里提起来时,左手直接软了提不起来,没办法只能一点点的铲了。晚上洗完澡躺倒床上,有点那种倒头就睡的冲动,今天要比昨天累很多。 第三天2020-07-29今天是我搬砖的第三天,天空很蓝,云朵很大,风很舒服,太阳很晒。今天的砖头比昨天格外的烫手,对面超市的冰镇可乐,依然是我不敢奢求的梦想,微分吹过我的脸庞,我很迷茫。 第四天2020-07-30中午下来一场雨,浸透了燥热的天空。让着原本燥热不堪看的气温竟夹带着一丝凉意,深深的呼吸新鲜空气,带着淡淡泥土的芬芳;让我这疲惫的身躯,重新焕发了一丝活力。下午的时候吊机出了一点问题,吊不起太多东西了,这使得我的工作轻松了许多,但无聊的时候,也是时间最漫长的时候,在这短暂而又漫长的时间里我会想着我昨天的代码和我的未来该何去何从~~~~ 第五天2020-07-31做了几天身体也渐渐适应了工作强度,手脚也不酸痛了。说说这几天的改变吧。最直观就是黑了很多就几天时间晒得跟包大人一样,我对着镜子又陷入了沉思,看来老天爷也不想让我白活一辈子。 身体素质上得到了小幅提升比如说手部力量和腿部力量,感觉比以前有力很多。不光这些连我的睡眠质量也得到了很大的改善,无论是晚上睡觉还是午休我都可以快速入睡,这是在学校时所没有的。这是几天搬砖最大的“收获”,有点困了今晚就这样了。 第六天2020-08-01今天是建军节。太阳出奇的大,气温是我从开始到现在最热的一天气温高达34度,感觉都要化了。不过还好今天不是很忙,今天楼上的砖差不多都砌完了,明天过后就会轻松很多。 第七天2020-08-02天气还可以不怎么热风很凉快,六点钟的时候下了场雨挺大的。无奈只能“暂停营业”,提前下班。 第八天2020-08-03今天建设局的人来检查,说违规建设未经允许私自加高楼层。听说这这个房子的主人只申请到了到了六层楼的文件建设许可,现在起到第八层局里的人说得拆掉两层,现在这栋房子的主人正在与局里的人沟通,估计明天也出不来结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搬砖日记","slug":"搬砖日记","permalink":"http://cokesprit.top/tags/%E6%90%AC%E7%A0%96%E6%97%A5%E8%AE%B0/"}]},{"title":"GO和AO","date":"2020-07-25T13:43:05.000Z","path":"/posts/GO-AO/","text":"GO: global object 全局的执行期上下文AO：activation object 活跃对象,函数的执行期上下文 暗示全局变量暗示全局变量 -&gt; imply global variable 12345678910111213141516171819202122232425// 栗子一 var a = 1; b = 2; // 暗示全局变量 不使用 var console.log(window.a); console.log(window.b); // a = window.a // b = window.b // window = { // a:1 , // b:2 // }// 栗子二 function test(){ var x = y = 7; } test(); console.log(y); // 打印 7 , 未声明直接赋值,提升成全局变量 // window 本身是一个全局的域;所有的全局变量都归 window 所有 // 你也可以这么认为 全局变量是 window对象的属性,全局函数是 window对象的方法 运行结果： 全局变量与GOjs在执行之前会产生一个叫GO的东西，GO又叫 -&gt; global object -&gt; 全局的执行期上下文 GO执行： 1. 找变量声明 2. 找函数声明 3. 执行 1234567891011121314// 栗子一 var a = 1; function a(){ console.log(2); } console.log(a); // 1 // 根据上面GO执行一步一步的来 // GO = { // a: undefined // a: function a(){} // a: 1 // } // 总结： GO === window,GO只关注全局变量的和全局函数声明并不关注函数的内部; 1234567891011// 栗子二 console.log(c,d); // 打印 f c(){} undefined function c(){} var d = funciton(){} // GO 执行 // GO = { // d:undefined // 第一步 找变量 // function(){} // c:function c(){} // 第二步 找函数声明 // } 疑点解析：为什么打印d是undefined并不是 f c(){}?因为预编译的时候是去找变量声明和函数声明,当编译完后才解释一行,执行一行。 总结：在使用 GO 的时候要考虑执行顺序。 函数预编译与AO函数预编译其实就是在函数执行之前要进行的一个步骤它这个步骤叫做AO：AO - &gt; activation object -&gt; 活跃对象 -&gt; 函数的执行期上下文 。它先创建AO这个对象AO = { }然后把形参和变量什么声明放到里面去，即AO执行： 寻找形参和变量声明 实参值赋值给形参 找函数声明,赋值 执行 123456789101112131415161718192021// 栗子一 function test(a){ console.log(a); // ƒ a(){} var a = 1; console.log(a); // 1 function a(){} // 1 var b = function(){} console.log(b); // ƒ (){} funciton d(){} } test(2); // AO = { // a: undefined -&gt; // 2 -&gt; // function a(){} -&gt; // 1 // b: undefined // function (){} // d: function d(){} // } 运行结果： 12345678910111213141516171819202122232425262728// 栗子二 function test(a,b){ console.log(a); // 1 c = 0; var c; a = 5; b = 6; console.log(b); // 6 function b(){} function d(){} console.log(b); // 6 因为 b = 6; 把函数式 function b(){} 给覆盖了 } test(1); // AO = { // a: undefined -&gt; // 1 -&gt; // 5, // b: undefined -&gt; // function b(){} -&gt; // 6, // c: undefined -&gt; // 0, // d:function d(){} // } 运行结果： 练习题写出练习例子的GO和AO 练习一12345678function test(){ return a; a = 1; function a(){} var a = 2; }console.log(test()); // ƒ a(){} 练习二1234567console.log(test()); //2function test(){ a = 1; function a(){} var a = 2; return a;} 练习三123456789101112131415161718192021 a = 1 ;function test(e){ function e(){} arguments[0] = 2; console.log(e); if(a){ var b = 3; } var c ; a = 4; var a; console.log(b); f = 5; console.log(c); console.log(a);}var a;test(1);console.log(a); //1console.log(f); //5 补充预编译是不看 if的,看见有声明就挂上去。if只有在在执行的时候才去看 if 。但是if 内部的变量声明还是看的。 为啥了解AO和GO为了解决js作用域/作用域链相关所产生的一切问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"http://cokesprit.top/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"预编译","date":"2020-07-25T07:37:53.000Z","path":"/posts/ab96ffb5/","text":"JavaScript在执行之前有几个步骤: 检查通篇的语法错误 预编译的过程 解释一行,执行一行 预编译代码演示 12345678910test(); // 2function test(){ console.log(2);}console.log(a); // undefined 如果不声明a然后直接打印的话就会报错var a = 10; // var a = 1 ; // 是2个步骤 编译时找a并且赋值undefined -&gt; 执行时赋值 1 运行结果： 上面的演示中test();打印出来了2,而console.log(a);打印出来了undefined并没有报错,证明 js引擎在编译的时候,先去找函数声明,和变量声明,而变量赋值并不是在编译的时候做的,而是在编译完成后执行到那句时做的。 总结：函数声明是整体提示的(函数内部的东西),变量只有声明提升,变量赋值不提升。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js作用域作用域链","slug":"js作用域作用域链","permalink":"http://cokesprit.top/tags/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"callee-caller","date":"2020-07-24T10:45:47.000Z","path":"/posts/callee-caller/","text":"calleecallee是arguments的属性,代表当前函数的引用(名字),在函数内部使用，主要用来配合立即执行函数。接下来让我们来认识 callee 12345678910function test(a,b,c){ console.log(arguments.callee); //打印的是这个函数本身 // 这两组是一样的 console.log(test.length);// 打印形参的长度 console.log(arguments.callee.length);//打印形参的长度 console.log(arguments.length);// 打印实参的长度}test(1,2); 运行结果： callee 配合立即执行函数 12345678// 使用递归求 n-1 的累加和 var sum = (function(n){ if(n &lt;= 1){ return 1; } return n + arguments.callee(n-1);}(10));console.log(sum); 运行结果： caller返回当前被调用的函数的引用。这听起来有点绕,让我们使用代码来更好的理解 1234567891011function test1(){ test2();}function test2(){ console.log(test2.caller); //这里打印的是 test1,因为test1()调用了test2并且test1执行了。 // 在被调用函数里面打印被调用函数的caller 它可以打印出谁在调用它。 // 注意一定是要被真正执行才能打印出来！！！}test1(); 运行结果： 注意在严格模式下 callee 和 caller 会报错!!! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面试/笔试","slug":"面试-笔试","permalink":"http://cokesprit.top/tags/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95/"}]},{"title":"call/apply方法","date":"2020-07-24T04:20:37.000Z","path":"/posts/call-apply/","text":"作用：call() 和 apply() 都是用来更改 this 指向;call()：call(this指向的对象, 参数1, 参数2, 参数n);apply()：apply(this指向的对象, []);不同之处：apply() 第二个参数是数组,实际开发中用的比较多的是apply(); 栗子栗子一让 newCar1和newCar2 拥有Car构造函数的的所有属性以及方法 1234567891011121314151617181920// Car function Car(brand,color){ this.brand = brand; this.color = color; this.run = function(){ console.log(this.color+\"的\"+this.brand+\"正在行驶\"); }} var newCar1 = { pdiliang:'3.0' }; var newCar2 = { pdiliang:'2.0' }; Car.call(newCar1,\"奔驰\",\"白色\"); console.log(newCar1); Car.apply(newCar2,[\"五菱宏光\",\"米色\"]); console.log(newCar2); 运行结果：可以看到 newCar1 和 newCar2 拥有了Car的属性和方法 栗子一讲解：12345678910// 当使用 newCar1/newCar2 的时候 Car 变成内部的情况是这样的function Car(){ newCar1.brand = brand; newCar1.color = color;}function Car(){ newCar2.brand = brand; newCar2.color = color;}// 因为 call/apply更改了 this 的指向 栗子二买车案例 1234567891011121314151617181920212223242526272829// 买车案例function Car(brand,color,displacement){ this.brand = brand; this.color = color; this.displacement = displacement; this.info = function(){ return '排量为'+ this.displacement + '的' + this.color + this.brand; }}function Preson(opt){ // 借用 Car 的属性和方法 Car.apply(this,[opt.brand,opt.color,opt.displacement]); this.name = opt.name; this.age = opt.age; this.say = function(){ console.log( '年龄'+ this.age + '岁姓名为'+this.name+'买了一辆'+this.info() ); }}var pt = new Preson({ brand:'法拉利', color:'红色', displacement:'3.5', name:'黄一蓝', age:'20'});pt.say(); 运行结果： call() 和 apply()的使用场景 以前写了一个功能不太完整，这时候可以写一个新的功能来补充完整，这个时候呢就可以使用 call() 和apply() 这两个方法去借用，以前功能相对应的方法和函数。 在工作的过程中很多人一起写个大功能，这个时候可以分组来写，最终统一去调用,一起协同作战。 分类：比如写一个东西，它有几种不同的类型，我们就可以分开写最后汇总。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面试/笔试","slug":"面试-笔试","permalink":"http://cokesprit.top/tags/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95/"}]},{"title":"立即执行函数","date":"2020-07-22T13:13:45.000Z","path":"/posts/iife/","text":"立即执行函数：解释：自动执行，执行完成立即释放（销毁） 英文：Immediately - Invoked Function Expression 简称：IIFE 作用：创建一个独立的作用域 好处：可以避免函数内的变量暴露在全局环境下，避免全局变量的污染。写法123456789// 写法一(function(){ })(); // 常用写法// 写法二(function(){}()); // w3C建议 演示错误声明12345678910 // 错误声明function test(){ console.log(\"这样是错误的声明\")}(); // 因为解析的时候是 ↓ function test(){ } (); //括号里面是空的会报错,当有值的时候会解析成一个表达式。 正确声明1234// 正确声明 var ts = function (){ // 这个匿名函数赋值给了 ts 这是一个赋值的过程 console.log(\"这样可以执行！\"); }(); 证明立即执行函数完就销毁1234567// 证明立即执行函数的销毁var testone = function(){ console.log(\"%c 1\",\"color:red;background:pink;\"); }(); // 这是一个赋值的过程 并不是执行所以可以这样写console.log(testone);//打印 undefined // 打印 undefined 证明 testone 在执行完之后就被销毁了 例子1234567891011// 例子一 (function(a,b){//这两个是形参 console.log(a+b); 6 }(2,4));//这两个是实参 // 例子二 var sum = (function(a,b){ return a + b; }(3,4)); console.log(sum); // 7 总结1.括号括起来的都是表达式,不管里面是什么;2.只有表达式才能被执行符号(括号)执行;3.把函数声明变成表达式，那么你的函数名就会被自动的忽略; 扩展函数声明变成表达式的方法函数声明变成表达式的方法在 function前面加 + 、- 、！、||(前面得加 0)、&amp;&amp;(前面得加 1) 12345678+function(){ console.log(\"我前面加了 + 号变成表达式了,所以可以立即执行\");}();0||function(){ console.log(\"我前面加了 0|| 运算符,我也变成表达式了,我也可以立即执行了。\");}(); 逗号运算符12345// 逗号运算符 // 逗号运算符只返回,所有逗号的最后一个值 // 例子： console.log((6-7,8+9,5+5)); // 10 console.log((4,5,7)); // 7 面试题1234567891011// 面试题function tst(a){ // console.log(\"不报错，也不运行\");}(6);// 解析流程 // 因为解析的时候是解析成两部分的 function tst(){ } //解析这是一个函数 (6); //这个(6),解析成一个表达式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://cokesprit.top/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"递归","date":"2020-07-21T08:23:14.000Z","path":"/posts/digui/","text":"什么是递归？递归说白了就是，函数自己调用自己。 递归主要的两个部分1.找到计算的规律!2.找到一个出口,让它结束掉! 栗子栗子一求 n 的阶乘 -&gt; 不能使用 for 循环 12345678910111213141516171819202122232425262728// fact(n);// 规律：n = n * fact(n-1)// 出口：n === 1 function fact(n){ //出口 if(n === 1){ return 1; } // 规律 return n * fact(n - 1); } console.log(fact(5));// 解析 // 当 n = 5; // 120 = fact(5) = 5 * fact(4); -&gt; 5 * 4 * 6; // 24 = fact(4) = 4 * fact(3); -&gt; 4 * 3 * 2; // 6 = fact(3) = 3 * fact(2); -&gt; 3 * 2 * 1; // 2 = fact(2) = 2 * fact(1); -&gt; 2 * 1 * 1; ↑ // 当程序走到出口1的时候又往上执行， // 因为上面还有一大堆队列都没有实际的运算结果，但是一到 1 // fact(1) = 1 然后 // 2 * 1 等于 2； fact(2) 等于 2; // 3 * 2 等于 6; fact(3) 等于 6; // 4 * 6 等于 24; fact(4) 等于 24; // 5 * 24 等于 120; fact(5) 等于 120; 栗子二斐波拉契数列 123456789101112131415161718192021222324252627//规律: n3 = n2 + n1;//出口：n &lt;= 0 n &lt;= 2; function fb(n){ // 两个出口 if(n &lt;= 0){ return 0; } if(n &lt;= 2){ return 1; } // 规律 return fb(n-1) + fb(n-2); } console.log(fb(6)); // 解析: // 斐波拉契数列： 0,1,1,2,3,5,8,13.... 像这种规律的。 // 规律：n3 = n2 + n1 // 出口：n &lt;= 0 n &lt;= 2 // n = 6; // 8 = fb(6) = fb(5) + fb(4); -&gt; 5 + 3 // 5 = fb(5) = fb(4) + fb(3); -&gt; 3 + 2 // 3 = fb(4) = fb(3) + fb(2); -&gt; 2 + 1 // 2 = fb(3) = fb(2) + fb(1); -&gt; 1 + 1 ↑ 总结递归它总是走到出口的时候,再向上一步一步的赋值计算后返回结果. 注意递归会涉及到性能的问题,return 的值一直出不去,要等执行到出口的时候。递归处理一些,小逻辑还是可以的,但是JavaScript里慎用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://cokesprit.top/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"js实参求乘积","date":"2020-07-19T07:25:53.000Z","path":"/posts/js-shican-qiu-chengji/","text":"在解题之前我们先搞懂什么是js中的形参和实参？ js中的形参和实参12345678 // 形式参数 形参function test(形参1,形参2){ // 里面的就是形参 console.log(test.length); // 形参长度 console.log(arguments.length);// 实参长度}// 实际参数 实参test(实参1,实参2,实参3);补充 形参和实参数量可以不相等。 arguments 是一个对应于传递给函数的参数的类数组对象里面包含所有的实参!!! 实参里面传了值的可以在函数内部修改实参的值，如果实参里面并没有传入值，也给形参赋值了，这样是没有用的。 js实参求乘积了解了什么实参和形参接下来就可以愉快的码代码了 123456789function sum(){var a = 1;for(var i = 0; i &lt; arguments.length;i++){ a *= arguments[i];}console.log(a);}sum(1,2,3,4); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js面试题","slug":"js面试题","permalink":"http://cokesprit.top/tags/js%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"ASCII码 和 UNICODE码","date":"2020-07-19T02:18:33.000Z","path":"/posts/504aee57/","text":"ASCII码0-127占一个byte大小，UNICODE码涵盖ASCII码 255 以后就占两个 byte大小。 练习 写一个函数，接收任意一个字符串，算出字符串的总字节数。 1234567891011function getBytes(str){ var sth = str.length; for(var i = 0; i &lt; str.length; i++){ var stc = str.charCodeAt(i); if(stc &gt; 255){ sth++; } } return sth;}console.log(getBytes('Hello js，我们做好朋友吧！')); 实现思路先获取到字符串的长度,将其存入一个变量 sth ,然后利用循环判断编码是否大于 255 ,如果大于 sth++ 。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://cokesprit.top/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"逻辑运算符","date":"2020-07-18T12:28:03.000Z","path":"/posts/17278be4/","text":"逻辑运算符：与&amp;&amp; 或|| 非! 在讲这个三个之前,先来认识js当中表示假的：undefined 、null、 NaN 、0 、false 、”” ，除上述以为全部都是真。 逻辑运算与：&amp;&amp;&amp;&amp;: 遇到真就会继续往前走，遇到假或者走到最后就返回当前的值。 12var a = 1 &amp;&amp; 2 &amp;&amp; undefined &amp;&amp; 10;console.log(a); 运行结果: 逻辑运算或： ||||:遇到假就会继续往前走,直到遇到真或者走到最后返回当前的值。 12var b = 0 || null || 1 || 0;console.log(b); 运行结果: 逻辑运算符非：!非就是取反，如果是真取反之后就是假，如果是假取反之后就是真。 1234567891011 var a = !true; // true 取反 -&gt; false console.log(a); var b = !1; console.log(b) var c = !c;/*注意此时的 c 未赋值还是 undefined , undefined取反就是真*/ console.log(c); //true 运行结果: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://cokesprit.top/tags/js%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo博客发布踩坑","date":"2020-07-18T02:29:37.000Z","path":"/posts/ffafe98e/","text":"hexo博客 Username for ‘https://github.com 验证问题这时候 输入你的github邮箱账号 （不是你的github名！！！） 之后会弹出一个提示框 然后输入邮箱登录密码即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"hexo","slug":"hexo","permalink":"http://cokesprit.top/tags/hexo/"}]},{"title":"hexo 博客文章发布部署","date":"2020-06-19T11:56:52.930Z","path":"/posts/c3259ce2/","text":"创建新帖子1$ hexo new \"My New Post\" 运行服务器1$ hexo server 生成静态文件1$ hexo generate 部署到远程站点$ hexo deploy 作者：可乐精链接：CokeSprit著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"hexo","slug":"hexo","permalink":"http://cokesprit.top/tags/hexo/"}]}]